# 04 - 时钟系统配置详解

> **难度**: ⭐⭐⭐⭐☆  
> **预计时间**: 60分钟  
> **前置要求**: 了解STM32时钟树结构

---

## 📋 目录

1. [STM32F103时钟树](#1-stm32f103时钟树)
2. [HSE+PLL配置](#2-hsepll配置)
3. [波特率计算原理](#3-波特率计算原理)
4. [时钟问题排查](#4-时钟问题排查)

---

## 1. STM32F103时钟树

### 1.1 时钟源选择

STM32F103支持3种时钟源：

| 时钟源 | 频率 | 精度 | 启动时间 | 用途 |
|-------|------|------|---------|------|
| **HSI** | 8MHz (RC振荡器) | ±1% | <2μs | 默认启动时钟 |
| **HSE** | 4-16MHz (外部晶振) | ±0.005% | <10ms | 高精度应用（本项目使用） |
| **LSI** | 40kHz (低速RC) | ±40% | <100μs | 看门狗、RTC |

**本项目使用HSE 8MHz外部晶振**，原因：
- ✅ 精度高，UART波特率误差 < 0.1%
- ✅ 稳定性好，温度影响小
- ✅ 可通过PLL倍频到72MHz

---

### 1.2 时钟树配置流程

```
HSE 8MHz (外部晶振)
   ↓
PLL ×9
   ↓
SYSCLK 72MHz (系统时钟)
   ↓
┌─────────┬─────────────────────┬─────────┐
│         │                     │         │
AHB       AHB/1 (72MHz)         │         │
│         ├─> HCLK (CPU)        │         │
│         ├─> DMA               │         │
│         └─> GPIO              │         │
│                               │         │
APB1 (÷2) APB1/2 (36MHz)        │         │
│         ├─> USART2/3          │         │
│         ├─> TIM2-4            │         │
│         └─> I2C1/2            │         │
│                               │         │
APB2 (÷1) APB2/1 (72MHz)        │         │
          ├─> USART1            │         │
          ├─> TIM1              │         │
          ├─> ADC1/2            │         │
          └─> SPI1              │         │
                                │         │
                             Flash        │
                           Latency=2      │
                          (2 wait states) │
```

**关键参数**：
- **SYSCLK**: 72MHz（最大值）
- **HCLK**: 72MHz（= SYSCLK）
- **APB1**: 36MHz（最大36MHz，限制因素）
- **APB2**: 72MHz（= HCLK）
- **Flash延迟**: 2个等待周期（48MHz < SYSCLK ≤ 72MHz时必需）

---

## 2. HSE+PLL配置

### 2.1 配置代码详解

**文件位置**: `Drivers/SYSTEM/sys/sys.c`

```c
void sys_stm32_clock_init(uint32_t plln)
{
    HAL_StatusTypeDef ret;
    RCC_OscInitTypeDef rcc_osc_init;
    RCC_ClkInitTypeDef rcc_clk_init;

    /* ===== 第1步：配置HSE和PLL ===== */
    rcc_osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSE;   // 选择HSE
    rcc_osc_init.HSEState = RCC_HSE_ON;                     // 使能HSE
    rcc_osc_init.HSEPredivValue = RCC_HSE_PREDIV_DIV1;      // HSE不分频
    rcc_osc_init.PLL.PLLState = RCC_PLL_ON;                 // 使能PLL
    rcc_osc_init.PLL.PLLSource = RCC_PLLSOURCE_HSE;         // PLL源=HSE
    rcc_osc_init.PLL.PLLMUL = plln;                         // PLL倍频系数(RCC_PLL_MUL9)
    
    ret = HAL_RCC_OscConfig(&rcc_osc_init);
    if (ret != HAL_OK)
    {
        while (1);  // HSE启动失败，死循环（实际应切换到HSI）
    }

    /* ===== 第2步：配置系统时钟和总线分频 ===== */
    rcc_clk_init.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK |
                               RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
    rcc_clk_init.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;    // SYSCLK = PLL输出
    rcc_clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;           // HCLK = SYSCLK / 1 = 72MHz
    rcc_clk_init.APB1CLKDivider = RCC_HCLK_DIV2;            // APB1 = HCLK / 2 = 36MHz
    rcc_clk_init.APB2CLKDivider = RCC_HCLK_DIV1;            // APB2 = HCLK / 1 = 72MHz
    
    ret = HAL_RCC_ClockConfig(&rcc_clk_init, FLASH_LATENCY_2);
    if (ret != HAL_OK)
    {
        while (1);
    }
}
```

### 2.2 PLL倍频计算

**公式**：
$$
f_{SYSCLK} = f_{HSE} \times PLLMUL
$$

**本项目**：
$$
f_{SYSCLK} = 8 \text{ MHz} \times 9 = 72 \text{ MHz}
$$

**可选倍频系数**（RCC_PLLMUL_xxx）：
| 宏定义 | 倍频 | HSE=8MHz时SYSCLK |
|--------|------|------------------|
| RCC_PLL_MUL2 | ×2 | 16MHz |
| RCC_PLL_MUL4 | ×4 | 32MHz |
| RCC_PLL_MUL6 | ×6 | 48MHz (USB时钟) |
| RCC_PLL_MUL9 | ×9 | 72MHz (最大值) ⭐ |

---

## 3. 波特率计算原理

### 3.1 BRR寄存器结构

USART的BRR (Baud Rate Register) 是16位寄存器：

```
BRR [15:4] - DIV_Mantissa (整数部分)
BRR [3:0]  - DIV_Fraction (小数部分)
```

**16倍过采样模式下的计算公式**：
$$
\text{BRR} = \frac{f_{PCLK}}{16 \times \text{baudrate}}
$$

### 3.2 USART1波特率计算（115200bps）

**已知条件**：
- APB2时钟：72MHz
- 目标波特率：115200bps
- 过采样：16倍

**计算过程**：
$$
\text{BRR} = \frac{72000000}{16 \times 115200} = \frac{72000000}{1843200} = 39.0625
$$

**拆分整数和小数部分**：
- 整数部分：39 = 0x27
- 小数部分：0.0625 × 16 = 1 = 0x1

**最终BRR值**：
$$
\text{BRR} = (39 << 4) | 1 = 0x0271 = 625
$$

**实际波特率**：
$$
\text{Actual Baudrate} = \frac{72000000}{16 \times 625} = 115200 \text{ bps}
$$

**误差**：0% ✅

---

### 3.3 USART2波特率计算（115200bps）

**已知条件**：
- APB1时钟：36MHz
- 目标波特率：115200bps

**计算过程**：
$$
\text{BRR} = \frac{36000000}{16 \times 115200} = \frac{36000000}{1843200} = 19.53125
$$

**拆分**：
- 整数部分：19 = 0x13
- 小数部分：0.53125 × 16 = 8.5 ≈ 8 = 0x8

**最终BRR值**：
$$
\text{BRR} = (19 << 4) | 8 = 0x0138 = 312
$$

**实际波特率**：
$$
\text{Actual Baudrate} = \frac{36000000}{16 \times 312} = 115384.6 \text{ bps}
$$

**误差**：
$$
\text{Error} = \frac{115384.6 - 115200}{115200} \times 100\% = 0.16\%
$$

**结论**：误差 < 2%，完全可用 ✅

---

### 3.4 常见波特率误差表

| 波特率 | APB时钟 | BRR值 | 实际波特率 | 误差 |
|-------|---------|-------|-----------|------|
| 9600 | 36MHz | 3906 | 9600.6 | +0.006% ✅ |
| 19200 | 36MHz | 1953 | 19200.8 | +0.004% ✅ |
| 38400 | 36MHz | 976 | 38461.5 | +0.16% ✅ |
| 57600 | 36MHz | 651 | 57600 | 0% ✅ |
| 115200 | 36MHz | 312 | 115384.6 | +0.16% ✅ |
| 230400 | 36MHz | 156 | 230769 | +0.16% ✅ |
| 460800 | 72MHz | 156 | 461538 | +0.16% ✅ |
| 921600 | 72MHz | 78 | 923076 | +0.16% ✅ |

**误差容限**：通常 < 2% 可正常通信，< 1% 稳定可靠

---

## 4. 时钟问题排查

### 4.1 HSE启动失败

**症状**：
- HAL_RCC_OscConfig() 返回 HAL_ERROR
- 系统卡死在while(1)
- SystemCoreClock = 8000000（回退到HSI）

**可能原因**：
1. **晶振未焊接**或焊接不良
2. **负载电容不匹配**（标准值：10-22pF）
3. **PCB走线过长**，寄生电容过大
4. **晶振型号错误**（需要8MHz ±20ppm）

**诊断步骤**：

```c
// 1. 检查HSE就绪标志
if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
{
    printf("HSE not ready!\r\n");
}

// 2. 读取RCC寄存器
uint32_t rcc_cr = RCC->CR;
printf("RCC_CR = 0x%08lX\r\n", rcc_cr);
// bit 17 (HSERDY): 应为1
// bit 16 (HSEON): 应为1

// 3. 检查SystemCoreClock
printf("SystemCoreClock = %lu Hz\r\n", SystemCoreClock);
// 预期：72000000
// 异常：8000000 (HSI)
```

**解决方案**：

**方案A**：硬件修复（首选）
- 更换晶振
- 检查负载电容（C1/C2，通常10-22pF）
- 缩短PCB走线

**方案B**：软件回退到HSI 8MHz

```c
void sys_stm32_clock_init_hsi(void)
{
    RCC_OscInitTypeDef rcc_osc_init;
    RCC_ClkInitTypeDef rcc_clk_init;
    
    /* 使用HSI 8MHz，不倍频 */
    rcc_osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    rcc_osc_init.HSIState = RCC_HSI_ON;
    rcc_osc_init.PLL.PLLState = RCC_PLL_NONE;  // 不使用PLL
    HAL_RCC_OscConfig(&rcc_osc_init);
    
    /* SYSCLK = HSI = 8MHz */
    rcc_clk_init.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK |
                              RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
    rcc_clk_init.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
    rcc_clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;
    rcc_clk_init.APB1CLKDivider = RCC_HCLK_DIV1;  // APB1 = 8MHz
    rcc_clk_init.APB2CLKDivider = RCC_HCLK_DIV1;  // APB2 = 8MHz
    HAL_RCC_ClockConfig(&rcc_clk_init, FLASH_LATENCY_0);
}
```

**注意**：使用HSI时，需手动计算USART BRR值（参考[03-双串口通信详解](./03-双串口通信详解.md#34-历史调试记录)）

---

### 4.2 波特率异常

**症状**：
- 串口输出乱码
- 接收数据错误
- 间歇性通信失败

**诊断代码**：

```c
void diagnose_uart_clock(void)
{
    uint32_t pclk1 = HAL_RCC_GetPCLK1Freq();
    uint32_t pclk2 = HAL_RCC_GetPCLK2Freq();
    uint32_t usart1_brr = USART1->BRR;
    uint32_t usart2_brr = USART2->BRR;
    
    printf("=== UART Clock Diagnostics ===\r\n");
    printf("SystemCoreClock: %lu Hz\r\n", SystemCoreClock);
    printf("APB1 Clock (USART2): %lu Hz\r\n", pclk1);
    printf("APB2 Clock (USART1): %lu Hz\r\n", pclk2);
    printf("\r\n");
    printf("USART1 BRR = 0x%04lX (%lu)\r\n", usart1_brr, usart1_brr);
    printf("  Expected: 0x0271 (625) for 115200@72MHz\r\n");
    printf("  Actual Baudrate: %lu bps\r\n", pclk2 / usart1_brr);
    printf("\r\n");
    printf("USART2 BRR = 0x%04lX (%lu)\r\n", usart2_brr, usart2_brr);
    printf("  Expected: 0x0138 (312) for 115200@36MHz\r\n");
    printf("  Actual Baudrate: %lu bps\r\n", pclk1 / usart2_brr);
}
```

**常见问题与解决**：

| 问题 | BRR值 | 实际时钟 | 解决方案 |
|------|-------|---------|---------|
| USART2乱码 | 68 (0x44) | 8MHz (APB1) | 修改时钟配置为72MHz模式 |
| USART1不工作 | 0 | 0MHz | 检查GPIO复用配置 |
| 波特率偏差大 | 不规则 | HSI未校准 | 切换到HSE |

---

### 4.3 Flash延迟配置

**重要**：SYSCLK > 48MHz时，必须设置Flash延迟：

```c
// 72MHz时钟需要2个等待周期
HAL_RCC_ClockConfig(&rcc_clk_init, FLASH_LATENCY_2);
```

| SYSCLK范围 | Flash延迟 | 宏定义 |
|-----------|-----------|--------|
| 0-24MHz | 0 wait states | FLASH_LATENCY_0 |
| 24-48MHz | 1 wait state | FLASH_LATENCY_1 |
| 48-72MHz | 2 wait states | FLASH_LATENCY_2 ⭐ |

**错误配置后果**：
- 程序运行不稳定
- 指令执行错误
- 随机死机

---

## 🎯 下一步

掌握时钟系统后，继续学习：

- **[05-CMake构建系统](./05-CMake构建系统.md)** - 理解编译流程
- **[06-调试技巧与问题排查](./06-调试技巧与问题排查.md)** - 综合调试方法

---

**返回**: [00-项目总览](./00-项目总览.md) | **上一篇**: [03-双串口通信详解](./03-双串口通信详解.md)
