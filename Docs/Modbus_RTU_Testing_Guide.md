# Modbus RTU 功能测试指南

## 📋 测试前准备

### 硬件连接
1. **USART2 (RS485)**: 连接Modbus主站设备
   - PA2 (TX) → RS485模块TXD
   - PA3 (RX) → RS485模块RXD
   - RS485 A/B线连接到Modbus主站

2. **USART1 (调试)**: 连接USB-TTL模块查看日志
   - PA9 (TX) → USB-TTL RX
   - 波特率: 115200-8-N-1

### 软件工具
- **推荐**: Modbus Poll (Windows)
- **备选**: ModScan, QModMaster
- **配置**: 
  - 模式: RTU
  - 从站地址: 1
  - 波特率: 115200
  - 数据位: 8
  - 停止位: 1
  - 校验位: None

---

## 🧪 测试用例

### 测试1: 读取系统状态寄存器（功能码0x03）

**目的**: 验证读保持寄存器功能

**操作步骤**:
1. 打开Modbus Poll，新建连接
2. 配置参数: 从站地址=1, 功能码=03, 起始地址=0x0000, 数量=10
3. 点击"读取"

**预期结果**:
```
寄存器地址  | 寄存器值 | 说明
0x0000     | 0x0000   | REG_SYS_ENABLE (初始无电机使能)
0x0001     | 0x0000   | REG_SYS_STATUS
0x0002     | 0x0000   | REG_SYS_ERROR_CODE
0x0007     | 0x0300   | REG_SYS_FIRMWARE_VERSION (V3.0)
0x0009     | 0x0001   | REG_SYS_DEVICE_ID (从站地址1)
```

**调试日志查看**:
```
[MODBUS] RX: 01 03 00 00 00 0A C5 CD
[MODBUS] TX: 01 03 14 00 00 00 00 00 00 ... <CRC>
```

---

### 测试2: 使能电机1（功能码0x06）

**目的**: 验证写单个寄存器功能

**操作步骤**:
1. 写寄存器 0x0100 (电机1_MOTOR_REG_ENABLE) = 0x0001
2. 观察电机状态

**Modbus报文**:
```
请求: 01 06 01 00 00 01 <CRC>  // 写0x0100寄存器值为1
响应: 01 06 01 00 00 01 <CRC>  // 回显确认
```

**预期结果**:
- 电机1使能成功
- 调试串口打印: `[EMM_V5] Motor 1 enabled`

---

### 测试3: 位置模式运动（功能码0x10）

**目的**: 验证写多个寄存器+执行命令

**操作步骤**:
1. 写入电机1控制参数（寄存器0x0100-0x0107）:
   ```
   0x0100: ENABLE = 1
   0x0101: CTRL_MODE = 1 (位置模式)
   0x0102: DIRECTION = 0 (顺时针)
   0x0103: SPEED = 300 (30.0 RPM)
   0x0104: ACCELERATION = 10
   0x0105: DECELERATION = 10
   0x0106: POSITION_H = 0
   0x0107: POSITION_L = 3200 (1圈, 16细分)
   ```

2. 写入执行命令寄存器 0x0108 = 0x0001 (启动运动)

**Modbus报文示例**:
```
// 步骤1: 写8个寄存器
01 10 01 00 00 08 10  // 功能码0x10, 地址0x0100, 数量8, 字节数16
00 01 00 01 00 00 01 2C  // ENABLE=1, MODE=1, DIR=0, SPEED=300
00 0A 00 0A 00 00 0C 80  // ACC=10, DEC=10, POS_H=0, POS_L=3200
<CRC>

// 步骤2: 启动执行
01 06 01 08 00 01 <CRC>  // 写0x0108寄存器值为1
```

**预期结果**:
- 电机1顺时针旋转1圈后停止
- 调试串口打印运动参数

---

### 测试4: 速度模式运动

**操作步骤**:
1. 写寄存器:
   ```
   0x0101: CTRL_MODE = 2 (速度模式)
   0x0103: SPEED = 500 (50.0 RPM)
   ```
2. 触发执行命令 0x0108 = 0x0001

**预期结果**:
- 电机1持续旋转
- 写入 CTRL_MODE=0 或 EXEC_COMMAND=0xFF 可停止

---

### 测试5: 多电机同步运动（功能码0x10）

**目的**: 验证多机同步功能

**前提**: 连接2个电机，地址分别为1和2

**操作步骤**:
1. 写电机1寄存器 0x0109 (SYNC_FLAG) = 1
2. 写电机1其他控制参数
3. 写电机2寄存器 0x0149 (SYNC_FLAG) = 1
4. 写电机2其他控制参数
5. 写全局寄存器 0x0010 (REG_SYNC_TRIGGER) = 1

**预期结果**:
- 两个电机同时启动
- 运动同步精度高

---

### 测试6: 读取电机状态（功能码0x04）

**目的**: 验证读输入寄存器（只读状态区）

**操作步骤**:
1. 读取地址 0x0500-0x0510 (电机1状态区)
2. 功能码选择 0x04 (读输入寄存器)

**预期结果**:
```
0x0500-0x0501: 实时位置（32位）
0x0502: 实时速度
0x0503: 实时电流
0x0510: 状态标志（运行中/到位/报警）
```

---

## 🔍 故障排查

### 问题1: 无响应
**检查项**:
- RS485 A/B线是否接反
- 从站地址是否匹配（默认1）
- 波特率是否正确（115200）
- USART2是否初始化成功

**调试方法**:
```c
// 在modbus_task_run()添加调试打印
printf("[MODBUS] Frame received: len=%d\r\n", g_emm_rx_count);
```

---

### 问题2: CRC校验失败
**原因**: 
- 数据传输错误
- CRC计算方式不匹配

**解决方案**:
- 检查modbus_crc16()实现
- 使用示波器查看RS485波形
- 降低波特率测试（如9600）

---

### 问题3: 寄存器地址错误（异常码0x02）
**原因**: 
- 访问的寄存器地址超出范围
- 控制区（0x0000-0x04FF）与状态区（0x0500-0x08FF）混淆

**解决方案**:
- 参考 `modbus_gateway.h` 确认地址映射
- 控制寄存器用0x03/0x06/0x10
- 状态寄存器用0x04

---

### 问题4: 电机不动作
**检查项**:
1. Modbus通信正常（有响应）
2. 电机是否使能（寄存器0x0100=1）
3. EXEC_COMMAND是否触发（寄存器0x0108=1）
4. 检查emm_v5回调是否正确注册:
   ```c
   // 在motor_zdt.c添加调试
   printf("[EMM] Callback registered: %p\r\n", cb->motor_pos_control);
   ```

---

## 📊 性能测试

### 响应时间测试
- **环境**: 115200 bps, 1个从站
- **测试指令**: 读10个寄存器
- **预期响应时间**: < 50ms

### 连续读写测试
- **操作**: 每100ms读取1次状态寄存器
- **持续时间**: 10分钟
- **预期**: 无丢帧，无异常

### 多机通信测试
- **环境**: 8个从站（地址1-8）
- **操作**: 轮询读取所有电机状态
- **预期**: 每轮询周期 < 500ms

---

## 📝 测试记录模板

| 测试用例 | 日期 | 结果 | 备注 |
|---------|------|------|------|
| 测试1: 读系统状态 | 2025-12-01 | ✅ PASS | 响应时间35ms |
| 测试2: 使能电机 | 2025-12-01 | ✅ PASS | |
| 测试3: 位置运动 | 2025-12-01 | ⏳ TODO | |
| 测试4: 速度运动 | 2025-12-01 | ⏳ TODO | |
| 测试5: 同步运动 | 2025-12-01 | ⏳ TODO | |
| 测试6: 读状态 | 2025-12-01 | ⏳ TODO | |

---

## 🚀 下一步优化方向

1. **DMA接收**: 替换IDLE中断，提升吞吐量
2. **帧超时检测**: 添加定时器检测帧间隔（3.5字符时间）
3. **寄存器持久化**: 保存配置参数到Flash
4. **状态轮询**: 定时读取电机反馈更新寄存器
5. **异常恢复**: 通信超时自动重连

---

**版本**: V1.0  
**作者**: STM32_485 Project Team  
**日期**: 2025-12-01
