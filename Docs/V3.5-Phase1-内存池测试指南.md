# 内存池硬件测试指南

**版本**: V3.5 Phase 1  
**测试日期**: 2025-12-02  
**测试平台**: STM32F103C8 (正点原子M48Z-M3开发板)  
**工具**: USMART串口调试系统 (115200bps)

---

## 一、测试前准备

### 1.1 硬件连接

```
PC (串口助手) <--USB转TTL--> STM32 USART1 (PA9/PA10)
        ↓
    115200-8-N-1
```

### 1.2 烧录固件

```bash
# 编译最新固件
cmake --build --preset Debug

# 烧录 (使用ST-Link或J-Link)
openocd -f interface/stlink.cfg -f target/stm32f1x.cfg \
  -c "program build/Debug/STM32_485.elf verify reset exit"
```

### 1.3 串口助手配置

- **波特率**: 115200
- **数据位**: 8
- **停止位**: 1
- **校验位**: 无
- **换行符**: CR+LF

---

## 二、可用测试命令

### 2.1 基础统计命令

```bash
? 或 help              # 查看所有可用命令
mem_stats()            # 显示内存池详细统计
mem_check_leaks()      # 扫描并报告泄漏 (检测5秒未释放的块)
mem_reset_stats(0)     # 重置帧缓冲池统计 (type=0)
mem_reset_stats(1)     # 重置电机状态池统计 (type=1)
```

### 2.2 硬件测试命令 (⭐新增)

```bash
mem_test_stress(1000)   # 压力测试：1000次分配/释放循环
mem_test_leak(2)        # 泄漏测试：故意分配2块不释放
mem_test_concurrent()   # 并发测试：分配至池满+重复释放检测
```

---

## 三、测试场景详解

### 场景1: 压力测试 (⭐必做)

**目标**: 验证内存池在高频分配/释放下的稳定性

**命令**:
```bash
mem_test_stress(1000)
```

**预期输出**:
```
[MEM_TEST] Starting stress test (1000 iterations)...
=========================================
[Frame Pool] Testing 1000 alloc/free cycles...
  Progress: 100/1000
  Progress: 200/1000
  ...
  Progress: 1000/1000

[Motor State Pool] Testing 1000 alloc/free cycles...
  Progress: 100/1000
  ...
  Progress: 1000/1000

=========================================
[MEM_TEST] Stress test completed
  Total iterations: 1000 x 2 pools = 2000
  Failed operations: 0
  Elapsed time: 120 ms
  Avg time per op: 60.00 us
  Result: ✓ PASSED
=========================================

========== Memory Pool Statistics ==========
[Frame Buffer Pool] (4 x 256B = 1024B total)
  Total Allocs:      1000
  Total Frees:       1000
  Current Used:      0 / 4 blocks (0%)
  Peak Used:         1 blocks
  Alloc Failures:    0
  Invalid Frees:     0
  Double Frees:      0
  Leak Warnings:     0
...
```

**验收标准**:
- ✅ `Failed operations: 0`
- ✅ `Current Used: 0` (所有内存已释放)
- ✅ `Alloc Failures: 0` (无分配失败)
- ✅ `Double Frees: 0` (无重复释放)
- ✅ `Leak Warnings: 0` (无泄漏)
- ✅ 平均时间 < 100 μs/op

---

### 场景2: 泄漏检测测试 (⭐必做)

**目标**: 验证5秒超时自动告警功能

**步骤**:

1️⃣ **分配内存但不释放**:
```bash
mem_test_leak(2)
```

**输出**:
```
[MEM_TEST] Starting leak test (allocating 2 blocks)...
=========================================
  ✓ Allocated block 1 at 0x20000100
  ✓ Allocated block 2 at 0x20000200

[MEM_TEST] Blocks allocated (intentional leak)
  Please wait 6 seconds, then call: mem_check_leaks()
  Expected: 2 leak warnings
  Allocation timestamp: 1234 ms
=========================================
```

2️⃣ **等待6秒** (超过5秒阈值)

3️⃣ **手动检查泄漏**:
```bash
mem_check_leaks()
```

**预期输出**:
```
[MEM_POOL] Leak Check Result: 2 blocks leaked

========== Memory Leak Report ==========
[Frame Buffer Pool]
  ⚠ Block 0 LEAKED: allocated at usmart_interface.c:260, 6.12s ago
  ⚠ Block 1 LEAKED: allocated at usmart_interface.c:260, 6.12s ago

[Motor State Pool]
  ✓ No leaks detected
========================================
```

**验收标准**:
- ✅ 检测到2个泄漏块
- ✅ 显示分配源文件和行号
- ✅ 显示泄漏持续时间 > 5秒

---

### 场景3: 并发分配测试 (⭐必做)

**目标**: 验证池满时正确返回NULL + 重复释放检测

**命令**:
```bash
mem_test_concurrent()
```

**预期输出**:
```
[MEM_TEST] Starting concurrent allocation test...
=========================================
[Frame Pool] Allocating until full...
  ✓ Block 1 allocated at 0x20000100
  ✓ Block 2 allocated at 0x20000200
  ✓ Block 3 allocated at 0x20000300
  ✓ Block 4 allocated at 0x20000400
  ✓ Block 5 allocation FAILED (expected, pool full)  ← 关键验证点

[Motor State Pool] Allocating until full...
  ✓ Block 1 allocated at 0x20000500
  ...
  ✓ Block 8 allocated at 0x20000800
  ✓ Block 9 allocation FAILED (expected, pool full)  ← 关键验证点

[MEM_TEST] Testing double free detection...
  First free: ✓ OK
  Double free: ✓ OK (expected: ERR_DOUBLE_FREE)      ← 关键验证点

[MEM_TEST] Cleaning up...
=========================================
[MEM_TEST] Concurrent test completed
=========================================
```

**验收标准**:
- ✅ 第5次帧分配失败 (池容量4)
- ✅ 第9次电机状态分配失败 (池容量8)
- ✅ 重复释放返回 `ERR_DOUBLE_FREE`
- ✅ 清理后 `Current Used: 0`

---

## 四、扩展测试 (可选)

### 4.1 长时间稳定性测试

**目标**: 验证48小时无泄漏

**方法**:
```bash
# 每5分钟执行一次压力测试 (可编写脚本自动化)
mem_test_stress(100)
mem_check_leaks()

# 48小时后检查统计
mem_stats()
```

**验收标准**:
- ✅ `Leak Warnings: 0`
- ✅ `Total Allocs == Total Frees`

### 4.2 实际业务场景测试

**修改main.c临时使用内存池**:
```c
/* 主循环中原有的栈分配 */
// uint8_t temp_frame_buffer[256];

/* 改为池分配 */
uint8_t* temp_frame_buffer = MEM_POOL_ALLOC_FRAME();
if (temp_frame_buffer == NULL) {
    printf("[ERROR] Frame pool exhausted!\r\n");
    continue;
}

// ...使用temp_frame_buffer处理Modbus帧...

mem_pool_free_frame(temp_frame_buffer);
```

**测试**:
- 发送大量Modbus请求
- 观察内存池统计：`mem_stats()`
- 验证无泄漏：`mem_check_leaks()`

---

## 五、故障排查

### 问题1: 压力测试失败 (Alloc Failures > 0)

**可能原因**:
- 池容量不足（当前4块帧缓冲）
- 某处代码未释放内存

**排查步骤**:
1. 查看失败迭代次数：`Alloc failed at iteration X`
2. 检查统计：`mem_stats()`
3. 检查泄漏：`mem_check_leaks()`
4. 如确需扩容，修改 `mem_pool.h`:
   ```c
   #define MEM_POOL_FRAME_COUNT  8  // 从4改为8
   ```

### 问题2: 泄漏检测误报

**可能原因**:
- 5秒阈值过短（某些长时间操作正常持有内存）

**解决方案**:
修改 `mem_pool.h`:
```c
#define MEM_POOL_LEAK_TIMEOUT_MS  10000  // 从5000改为10000 (10秒)
```

### 问题3: 并发测试池满检测失败

**可能原因**:
- 之前测试未清理内存

**解决方案**:
```bash
# 重启系统清空内存池
# 或手动释放所有块（危险，仅测试用）
```

---

## 六、测试报告模板

```
========== 内存池硬件测试报告 ==========
测试日期: 2025-12-02
测试人员: [你的名字]
固件版本: V3.5 Phase 1 (Commit: 9f10934)
硬件平台: STM32F103C8

【场景1: 压力测试】
命令: mem_test_stress(1000)
结果: ✓ PASSED / ✗ FAILED
失败次数: 0
平均时间: 60 us/op
备注: 无

【场景2: 泄漏检测】
命令: mem_test_leak(2) → 等待6秒 → mem_check_leaks()
结果: ✓ PASSED / ✗ FAILED
检测到泄漏: 2 blocks
泄漏持续时间: 6.12s
备注: 告警正常触发

【场景3: 并发分配】
命令: mem_test_concurrent()
结果: ✓ PASSED / ✗ FAILED
池满检测: ✓ 正确返回NULL
重复释放检测: ✓ 正确返回ERR_DOUBLE_FREE
备注: 无

【总结】
✅ 所有核心功能验证通过
✅ 内存池可投入实际使用
建议: [如有]

签名: _______________  日期: __________
========================================
```

---

## 七、下一步

测试通过后，可以：

1. **提交测试报告** 到 `Docs/V3.5-Phase1-测试报告.md`
2. **合并到主分支**:
   ```bash
   git checkout main
   git merge feature/architecture-optimization
   ```
3. **开始状态机实现** (Phase 1 第二阶段)

---

**重要提示**: 
- 测试过程中如遇到**看门狗复位**，说明测试时间过长（>2秒）。建议暂时禁用看门狗：
  ```c
  // main.c 中注释掉
  // #define FEATURE_WATCHDOG_ENABLE
  ```
- 泄漏测试后，如需清理泄漏的内存，**重启开发板**即可（内存池在RAM中，断电清空）。

---

**联系与反馈**: 如发现BUG或有改进建议，请在项目Issue中反馈。
