# Phase 7-01: 48小时长时间运行测试

**测试类型**: 稳定性验证  
**测试等级**: P0（必须通过）  
**预计耗时**: 48小时 + 4小时准备与分析  
**自动化程度**: 半自动（需人工定期巡检）

---

## 📋 测试目标

### 主要验证点
1. **系统稳定性**: 验证固件在长时间运行下无崩溃、无内存泄漏
2. **通信可靠性**: RS485通信在48小时内保持高成功率
3. **看门狗机制**: IWDG看门狗正确工作，异常情况下能自动恢复
4. **电机耐久性**: 步进电机在连续运行下无失步、无过热
5. **资源管理**: 系统资源（堆栈、FIFO）无溢出

### 验收标准
| 指标项 | 目标值 | 测量方法 |
|--------|--------|----------|
| 系统崩溃次数 | 0次 | 串口日志监控 |
| 看门狗复位次数 | ≤5次 | 复位计数器 |
| 通信成功率 | ≥99.9% | 统计TX/RX计数 |
| 电机失步次数 | 0次 | 编码器反馈校验 |
| 内存泄漏 | 0字节 | 堆栈水位线检测 |
| 平均响应延迟 | <10ms | 时间戳分析 |
| 最大响应延迟 | <50ms | 时间戳分析 |

---

## 🔧 测试前准备

### 硬件配置检查清单

```
✓ STM32F103开发板固定在防震垫上
✓ 电机固定在测试台座，确保无振动位移
✓ 所有连接线使用扎带固定，防止松动
✓ 24V电源连接UPS不间断电源
✓ 散热风扇对准STM32和电机驱动器
✓ 温湿度计放置在测试区域
✓ 串口USB线使用有磁环的屏蔽线
✓ 准备备用电源和开发板（应急替换）
```

### 固件配置

#### 启用统计功能（app_config.h）
```c
/* 长时间测试专用配置 */
#define FEATURE_WATCHDOG_ENABLE     1      // 看门狗必须启用
#define FEATURE_DEBUG_STATS         1      // 统计功能
#define FEATURE_HEARTBEAT_LED       1      // 心跳LED指示
#define LOG_INTERVAL_SECONDS        60     // 日志输出间隔60秒

/* 通信超时配置 */
#define RS485_TIMEOUT_MS            100    // 100ms超时
#define RS485_RETRY_COUNT           3      // 重试3次

/* 电机参数 */
#define MOTOR_SPEED_DEFAULT         300    // 默认速度300RPM
#define MOTOR_ACCELERATION          10     // 加速度10
#define MOTOR_PULSES_PER_CIRCLE     3200   // 3200脉冲/圈
```

#### 添加统计代码（motor_zdt.c）
```c
/* 添加到motor_zdt.c的全局变量 */
static uint32_t g_total_commands = 0;
static uint32_t g_error_count = 0;
static uint32_t g_last_report_time = 0;
static uint32_t g_watchdog_reset_count = 0;

/* 在motor_zdt_task()主循环中添加统计输出 */
void motor_zdt_task(void)
{
    uint32_t current_time = HAL_GetTick();
    
    // 每60秒输出一次统计信息
    if (current_time - g_last_report_time >= 60000) {
        emm_uart_stats_t stats;
        emm_uart_get_stats(&stats);
        
        printf("\n===== Runtime Statistics =====\n");
        printf("Uptime: %lu seconds\n", current_time / 1000);
        printf("Total Commands: %lu\n", g_total_commands);
        printf("Error Count: %lu\n", g_error_count);
        printf("TX Success: %lu\n", stats.tx_success);
        printf("TX Error: %lu\n", stats.tx_error);
        printf("RX Frames: %lu\n", stats.rx_frames);
        printf("Success Rate: %.2f%%\n", 
               100.0 * stats.tx_success / (stats.tx_success + stats.tx_error + 1));
        printf("Watchdog Resets: %lu\n", g_watchdog_reset_count);
        printf("==============================\n\n");
        
        g_last_report_time = current_time;
    }
}
```

#### 检测看门狗复位（main.c）
```c
/* 在main()函数开头添加 */
int main(void)
{
    HAL_Init();
    
    // 检查复位原因
    if (__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST) != RESET) {
        printf("!!! IWDG Reset Detected !!!\n");
        g_watchdog_reset_count++;
        __HAL_RCC_CLEAR_RESET_FLAGS();
    }
    
    // 其余初始化代码...
}
```

### 日志记录工具配置

#### 使用Putty自动记录（推荐）
```
1. 打开Putty配置界面
2. Session -> Logging:
   - Session logging: All session output
   - Log file name: D:\Test_Logs\48h_test_&Y&M&D_&T.log
   - Log file clash: Append
3. Connection -> Serial:
   - Serial line: COM3 (根据实际修改)
   - Speed: 115200
   - Data bits: 8, Stop bits: 1, Parity: None
4. 保存会话名称为"STM32_48H_Test"
```

#### 使用XCOM串口助手
```
1. 打开XCOM，连接USART1对应COM口
2. 勾选"接收区显示时间"
3. 勾选"自动保存接收数据"
4. 设置保存路径: D:\Test_Logs\48h_xcom.txt
5. 接收设置: 十六进制显示关闭，自动换行
```

---

## 🚀 测试执行步骤

### 测试场景一：位置模式连续运行（T7.1.1）

#### 测试目的
验证电机在位置模式下重复往返运动48小时的稳定性，这是最常见的工业应用场景。

#### 测试参数
```c
电机地址: 0x01
运动模式: 相对位置模式
速度: 300 RPM
加速度: 10
单次脉冲数: 3200 (1圈)
方向: 交替（顺时针/逆时针）
循环间隔: 2秒（电机转1圈用时约600ms，留1.4s缓冲）
预计总循环次数: 48h * 3600s/h / 2s = 86400次
预计总圈数: 86400圈
```

#### 自动化脚本（USMART命令）

**方案A: 手动循环（简单但需人工重复）**
```bash
# 在串口助手中手动输入（用于短时间测试）
motor_enable(1,1)
motor_pos_move(1,0,300,10,3200)
delay_ms(2000)
motor_pos_move(1,1,300,10,3200)
delay_ms(2000)
# 重复上述命令...
```

**方案B: 修改固件添加自动测试模式（推荐）**

在`motor_zdt.c`中添加自动测试功能：

```c
/* 添加到motor_zdt.c */
static uint8_t g_auto_test_mode = 0;  // 0=关闭, 1=位置模式, 2=速度模式
static uint32_t g_test_cycle_count = 0;
static uint32_t g_test_start_time = 0;

/**
 * @brief 自动测试任务（48小时位置模式）
 */
void auto_test_position_mode(void)
{
    static uint32_t last_move_time = 0;
    static uint8_t direction = 0;
    uint32_t current_time = HAL_GetTick();
    
    // 首次启动
    if (g_test_cycle_count == 0) {
        g_test_start_time = current_time;
        Emm_V5_En_Control(MOTOR_ADDRESS, 1, 0);  // 使能电机
        HAL_Delay(100);
        printf("=== Auto Test Started ===\n");
        printf("Mode: Position (48h)\n");
        printf("Start Time: %lu ms\n", g_test_start_time);
    }
    
    // 每2秒执行一次运动
    if (current_time - last_move_time >= 2000) {
        // 交替方向运动
        uint8_t result = Emm_V5_Pos_Control(
            MOTOR_ADDRESS,
            direction,
            MOTOR_SPEED_DEFAULT,
            MOTOR_ACCELERATION,
            MOTOR_PULSES_PER_CIRCLE,
            0,  // 相对位置
            0   // 立即执行
        );
        
        if (result == 1) {
            g_total_commands++;
            g_test_cycle_count++;
            direction = !direction;  // 切换方向
            
            // 每100次循环输出进度
            if (g_test_cycle_count % 100 == 0) {
                uint32_t elapsed_hours = (current_time - g_test_start_time) / 3600000;
                printf("[Progress] Cycles: %lu, Hours: %lu, Direction: %s\n",
                       g_test_cycle_count, elapsed_hours,
                       direction ? "CCW" : "CW");
            }
        } else {
            g_error_count++;
            printf("[ERROR] Command failed at cycle %lu\n", g_test_cycle_count);
        }
        
        last_move_time = current_time;
    }
    
    // 达到48小时停止测试
    if (current_time - g_test_start_time >= 172800000UL) {  // 48h = 172800000ms
        g_auto_test_mode = 0;
        printf("\n===== 48H Test Completed =====\n");
        printf("Total Cycles: %lu\n", g_test_cycle_count);
        printf("Total Errors: %lu\n", g_error_count);
        printf("==============================\n");
    }
}

/**
 * @brief 在主循环中调用
 */
void motor_zdt_task(void)
{
    // 自动测试模式
    if (g_auto_test_mode == 1) {
        auto_test_position_mode();
        return;  // 自动测试时不处理按键
    }
    
    // 原有的按键控制代码...
}
```

**启动自动测试**（通过USMART命令）：
```c
/* 在app_functions.h添加 */
void start_auto_test(uint8_t mode);

/* 在motor_zdt.c实现 */
void start_auto_test(uint8_t mode)
{
    if (mode == 1 || mode == 2) {
        g_auto_test_mode = mode;
        g_test_cycle_count = 0;
        printf("Auto test mode %d started\n", mode);
    }
}

/* 在usmart_config.c注册 */
{(void *)start_auto_test, "void start_auto_test(uint8_t mode)"},
```

**串口助手操作**：
```bash
start_auto_test(1)  # 启动位置模式48小时测试
# 然后就可以离开，每小时回来检查一次日志
```

#### 测试执行时间表

| 时间点 | 操作 | 检查项 |
|--------|------|--------|
| 0h (Day1 10:00) | 启动测试 | ✓ 电机使能成功<br>✓ 首次运动正常<br>✓ 日志开始记录 |
| 1h | 首次巡检 | ✓ 循环计数约1800次<br>✓ 无错误日志<br>✓ 温度正常(<50°C) |
| 6h | 定期巡检 | ✓ 循环计数约10800次<br>✓ 通信成功率>99.9%<br>✓ 看门狗复位次数≤1 |
| 12h (Day1 22:00) | 睡前检查 | ✓ 循环计数约21600次<br>✓ 系统稳定<br>✓ 检查电源线牢固 |
| 24h (Day2 10:00) | 中期检查 | ✓ 循环计数约43200次<br>✓ 统计数据导出<br>✓ 检查电机轴承温度 |
| 36h (Day2 22:00) | 睡前检查 | ✓ 循环计数约64800次<br>✓ 检查FIFO无溢出 |
| 48h (Day3 10:00) | 测试结束 | ✓ 循环计数约86400次<br>✓ 导出完整日志<br>✓ 分析统计数据 |

#### 巡检操作规程

每次巡检按以下顺序执行：

1. **观察LED状态**
   - LED0应每秒闪烁一次（心跳灯）
   - LED1指示电机状态（运行时应闪烁）

2. **检查串口日志**
   - 查看最新的统计输出
   - 确认无"ERROR"字样
   - 记录当前循环计数

3. **物理检查**
   - 手背轻触STM32芯片（不应烫手，<60°C）
   - 手背轻触电机外壳（<50°C为正常）
   - 听电机声音（应平稳，无异响）
   - 检查连接线无松动

4. **记录数据**（填写到巡检表）
   ```
   时间: 2025-12-02 16:00
   运行时长: 6h
   循环次数: 10853
   错误次数: 0
   环境温度: 25°C
   STM32温度: 45°C (估算)
   电机温度: 42°C
   备注: 一切正常
   ```

5. **喂狗测试**（可选）
   - 按下开发板复位按钮，观察是否快速恢复运行
   - 或发送`motor_stop(1)`后重新`start_auto_test(1)`

---

### 测试场景二：速度模式连续运行（T7.1.2）

#### 测试目的
验证电机在速度模式下长时间单向旋转的稳定性，模拟风扇、输送带等连续运转场景。

#### 测试参数
```c
电机地址: 0x01
运动模式: 速度模式（连续旋转）
速度: 500 RPM
加速度: 20
方向: 顺时针
运行时长: 48小时
预计总圈数: 500 * 60 * 48 = 1,440,000 圈
```

#### 自动化脚本

```c
/* 在motor_zdt.c添加速度模式测试函数 */
void auto_test_velocity_mode(void)
{
    static uint8_t started = 0;
    uint32_t current_time = HAL_GetTick();
    
    // 启动速度模式
    if (!started) {
        g_test_start_time = current_time;
        Emm_V5_En_Control(MOTOR_ADDRESS, 1, 0);
        HAL_Delay(100);
        
        uint8_t result = Emm_V5_Vel_Control(
            MOTOR_ADDRESS,
            0,      // 顺时针
            500,    // 500 RPM
            20,     // 加速度
            0       // 立即执行
        );
        
        if (result == 1) {
            started = 1;
            printf("=== Velocity Mode Test Started ===\n");
            printf("Speed: 500 RPM, Direction: CW\n");
            printf("Duration: 48 hours\n");
        } else {
            printf("ERROR: Failed to start velocity mode\n");
            g_auto_test_mode = 0;
            return;
        }
    }
    
    // 达到48小时停止
    if (current_time - g_test_start_time >= 172800000UL) {
        Emm_V5_Stop_Now(MOTOR_ADDRESS, 0);
        g_auto_test_mode = 0;
        printf("\n===== Velocity Test Completed =====\n");
        printf("Runtime: 48 hours\n");
        printf("Estimated Rotations: %lu\n", 500UL * 60 * 48);
    }
}

/* 在motor_zdt_task()中添加 */
if (g_auto_test_mode == 2) {
    auto_test_velocity_mode();
    return;
}
```

**启动命令**：
```bash
start_auto_test(2)  # 启动速度模式48小时测试
```

#### 速度模式特殊检查项

| 检查项 | 正常标准 | 异常处理 |
|--------|----------|----------|
| 电机转速 | 稳定在500±10 RPM | 使用转速计测量，偏差>20RPM需停机检查 |
| 轴承温度 | <60°C | >60°C降低速度至300RPM |
| 振动噪音 | 平稳低噪 | 出现共振频率需调整速度 |
| 编码器反馈 | 连续无丢步 | 使用示波器检查编码器信号 |

---

## 📊 数据记录与分析

### 自动日志分析脚本（Python）

将以下脚本保存为`analyze_48h_log.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
48小时测试日志分析工具
用法: python analyze_48h_log.py logfile.txt
"""

import re
import sys
from datetime import datetime, timedelta

def parse_log(filename):
    """解析日志文件"""
    stats = {
        'total_commands': 0,
        'error_count': 0,
        'watchdog_resets': 0,
        'tx_success': 0,
        'tx_error': 0,
        'rx_frames': 0,
        'cycles': 0,
        'start_time': None,
        'end_time': None
    }
    
    error_log = []
    
    with open(filename, 'r', encoding='utf-8') as f:
        for line in f:
            # 提取统计数据
            if 'Total Commands:' in line:
                stats['total_commands'] = int(re.search(r'(\d+)', line).group(1))
            elif 'Error Count:' in line:
                stats['error_count'] = int(re.search(r'(\d+)', line).group(1))
            elif 'TX Success:' in line:
                stats['tx_success'] = int(re.search(r'(\d+)', line).group(1))
            elif 'TX Error:' in line:
                stats['tx_error'] = int(re.search(r'(\d+)', line).group(1))
            elif 'Watchdog Resets:' in line:
                stats['watchdog_resets'] = int(re.search(r'(\d+)', line).group(1))
            elif 'Cycles:' in line:
                match = re.search(r'Cycles: (\d+)', line)
                if match:
                    stats['cycles'] = max(stats['cycles'], int(match.group(1)))
            
            # 记录错误
            if 'ERROR' in line or 'FAIL' in line:
                error_log.append(line.strip())
            
            # 记录开始时间
            if 'Auto Test Started' in line and stats['start_time'] is None:
                stats['start_time'] = line[:19]  # 假设日志有时间戳
            
            # 记录结束时间
            if 'Test Completed' in line:
                stats['end_time'] = line[:19]
    
    return stats, error_log

def generate_report(stats, error_log):
    """生成测试报告"""
    print("\n" + "="*60)
    print("48小时长时间运行测试报告")
    print("="*60)
    
    print(f"\n【测试概况】")
    print(f"开始时间: {stats['start_time']}")
    print(f"结束时间: {stats['end_time']}")
    print(f"总循环次数: {stats['cycles']}")
    print(f"总命令数: {stats['total_commands']}")
    
    print(f"\n【通信统计】")
    total_tx = stats['tx_success'] + stats['tx_error']
    success_rate = 100.0 * stats['tx_success'] / total_tx if total_tx > 0 else 0
    print(f"发送成功: {stats['tx_success']}")
    print(f"发送失败: {stats['tx_error']}")
    print(f"成功率: {success_rate:.3f}%")
    print(f"接收帧数: {stats['rx_frames']}")
    
    print(f"\n【错误统计】")
    print(f"通信错误: {stats['error_count']}")
    print(f"看门狗复位: {stats['watchdog_resets']}")
    
    print(f"\n【测试结论】")
    # 判断是否通过
    passed = True
    reasons = []
    
    if success_rate < 99.9:
        passed = False
        reasons.append(f"通信成功率{success_rate:.2f}%低于99.9%")
    
    if stats['watchdog_resets'] > 5:
        passed = False
        reasons.append(f"看门狗复位{stats['watchdog_resets']}次超过5次")
    
    if len(error_log) > 10:
        passed = False
        reasons.append(f"错误日志{len(error_log)}条超过10条")
    
    if passed:
        print("✅ 测试通过 (PASS)")
    else:
        print("❌ 测试失败 (FAIL)")
        print("\n失败原因:")
        for reason in reasons:
            print(f"  - {reason}")
    
    if error_log:
        print(f"\n【错误详情】(共{len(error_log)}条)")
        for i, err in enumerate(error_log[:10], 1):  # 只显示前10条
            print(f"{i}. {err}")
        if len(error_log) > 10:
            print(f"... 还有{len(error_log)-10}条错误，请查看原始日志")
    
    print("\n" + "="*60)

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("用法: python analyze_48h_log.py <日志文件>")
        sys.exit(1)
    
    filename = sys.argv[1]
    stats, error_log = parse_log(filename)
    generate_report(stats, error_log)
```

**使用方法**：
```powershell
python analyze_48h_log.py D:\Test_Logs\48h_test.log
```

### 手动数据记录表

| 时间 | 运行时长 | 循环次数 | 错误次数 | 看门狗复位 | STM32温度 | 电机温度 | 环境温度 | 备注 |
|------|----------|----------|----------|------------|-----------|----------|----------|------|
| 10:00 | 0h | 0 | 0 | 0 | 30°C | 28°C | 22°C | 测试开始 |
| 11:00 | 1h | 1800 | 0 | 0 | 45°C | 42°C | 23°C | 正常 |
| 16:00 | 6h | 10850 | 0 | 0 | 48°C | 45°C | 24°C | 正常 |
| 22:00 | 12h | 21700 | 0 | 1 | 47°C | 44°C | 22°C | 1次看门狗复位 |
| ... | ... | ... | ... | ... | ... | ... | ... | ... |

---

## ⚠️ 异常情况处理

### 常见异常及应对方案

#### 1. 看门狗频繁复位（>5次/小时）
**现象**: 日志中频繁出现"IWDG Reset Detected"

**可能原因**:
- FIFO溢出导致中断响应超时
- 某个函数执行时间过长（>2秒）
- 栈溢出导致程序跑飞

**处理步骤**:
```bash
1. 立即记录复位前的日志
2. 检查FIFO使用率（添加调试代码）
3. 增加喂狗频率（缩短IWDG超时时间）
4. 使用调试器单步查找死循环
5. 检查栈大小是否足够（默认0x400）
```

#### 2. 通信成功率骤降（<95%）
**现象**: "Success Rate"从99.9%突然下降

**可能原因**:
- RS485线缆松动或接触不良
- 电磁干扰增强
- 电机驱动器进入保护模式

**处理步骤**:
```bash
1. 检查RS485 A/B线连接牢固性
2. 使用示波器查看RS485差分信号质量
3. 增加RS485通信重试次数
4. 检查电源纹波是否过大（>500mV）
5. 更换屏蔽性能更好的线缆
```

#### 3. 电机失步
**现象**: 电机位置与预期不符，编码器反馈异常

**可能原因**:
- 速度或加速度设置过高
- 机械负载突然增大
- 电源电压不足

**处理步骤**:
```bash
1. 降低速度至200 RPM重新测试
2. 增加加速度至15或20
3. 检查24V电源电压是否稳定
4. 减轻机械负载
5. 检查电机轴是否卡顿
```

#### 4. 系统完全无响应
**现象**: 串口无输出，LED不闪烁

**应急处理**:
```bash
1. 按下复位按钮尝试恢复
2. 如复位无效，断电10秒后重新上电
3. 使用ST-Link连接，查看是否进入HardFault
4. 重新烧录固件
5. 更换备用开发板继续测试
```

### 紧急停止流程

```
【紧急停止标准操作程序（SOP）】

触发条件:
  - 冒烟或异味
  - 温度超过80°C
  - 异常噪音或振动
  - 持续错误超过1分钟

操作步骤:
  1. 按下急停按钮或拔掉24V电源插头
  2. 保持STM32上电，记录最后的日志
  3. 拍照记录硬件状态
  4. 导出完整日志文件
  5. 填写事故报告表
  6. 分析根本原因后再恢复测试
```

---

## ✅ 测试完成标准

### 必须满足的硬指标
- [ ] 运行满48小时无人工中断
- [ ] 系统崩溃次数 = 0
- [ ] 看门狗复位次数 ≤ 5
- [ ] 通信成功率 ≥ 99.9%
- [ ] 电机失步次数 = 0

### 建议达到的软指标
- [ ] 平均响应延迟 < 10ms
- [ ] 最大响应延迟 < 50ms
- [ ] 错误日志 < 10条
- [ ] 温度波动 < 10°C
- [ ] FIFO最大占用率 < 80%

### 测试交付物清单
- [ ] 完整48小时日志文件（.log格式）
- [ ] 数据分析报告（Excel或Python生成）
- [ ] 巡检记录表（手写或电子表格）
- [ ] 测试照片（测试环境、硬件连接）
- [ ] 异常情况说明（如有）
- [ ] 改进建议文档

---

## 📈 后续优化建议

根据48小时测试结果，可能的优化方向：

1. **通信优化**
   - 如成功率<99.9%，增加CRC校验
   - 优化RS485发送时序
   - 增加DMA传输模式

2. **看门狗策略**
   - 如复位次数>5，增加超时时间至4秒
   - 在关键代码段禁止中断
   - 优化FIFO处理逻辑

3. **散热改进**
   - 如温度>60°C，增加散热片
   - 优化PCB布局
   - 降低运行速度

4. **电源管理**
   - 增加电源滤波电容
   - 使用更高质量的24V电源
   - 增加电压监测功能

---

**文档结束 | 下一步: 阅读 `V3.5-Phase7-02-故障注入测试.md`**
