# Phase 7-02: 故障注入测试手册

**测试类型**: 容错性与安全性验证  
**测试等级**: P0/P1混合  
**预计耗时**: 8小时  
**危险等级**: ⚠️ 中等（涉及电源断电、线缆拔插等破坏性操作）

---

## 📋 测试目标

### 验证目标
通过人为注入各种故障场景，验证系统在异常情况下的：
1. **容错能力**: 能否检测异常并采取保护措施
2. **恢复能力**: 故障解除后能否自动或手动恢复正常
3. **安全性**: 异常情况下不损坏硬件、不造成危险
4. **数据完整性**: 故障过程中不丢失关键数据

### 测试范围

| 故障类型 | 测试项 | 优先级 | 风险等级 |
|----------|--------|--------|----------|
| 电源故障 | 电源跌落恢复 | P0 | 低 |
| 通信故障 | RS485断线重连 | P0 | 低 |
| 通信故障 | 通信超时与重试 | P1 | 低 |
| 通信故障 | 帧错误注入 | P1 | 低 |
| 机械故障 | 电机堵转保护 | P0 | 中 |
| 软件故障 | 看门狗强制复位 | P1 | 低 |
| 环境故障 | EMI电磁干扰 | P2 | 中 |
| 环境故障 | 温度极限测试 | P2 | 高 |

**风险等级说明**:
- **低**: 不会损坏硬件，可频繁测试
- **中**: 可能影响设备寿命，适度测试
- **高**: 可能损坏硬件，谨慎执行

---

## 🔧 测试前准备

### 专用工具清单

| 工具名称 | 用途 | 必要性 |
|----------|------|--------|
| 可调稳压电源 | 模拟电压跌落 | 必需 |
| 万用表 | 测量电压电流 | 必需 |
| 示波器 | 观察波形畸变 | 推荐 |
| 继电器模块 | 自动断电测试 | 可选 |
| 负载飞轮 | 机械堵转测试 | 推荐 |
| 热风枪/冰箱 | 温度测试 | 可选 |
| EMI发生器 | 电磁干扰测试 | 可选 |

### 安全防护措施

```
【安全须知】
1. 所有断电操作前先记录当前状态
2. 电源电压调节范围: 20V-26V（勿超出）
3. 堵转测试时间不超过5秒（防过热）
4. 每个测试项间隔至少5分钟（散热）
5. 准备灭火器（应对极端情况）
6. 测试区域禁止放置易燃物品
7. 操作时佩戴防护眼镜
```

### 测试固件配置

#### 启用故障检测功能（app_config.h）
```c
/* 故障注入测试专用配置 */
#define FEATURE_FAULT_DETECTION     1      // 启用故障检测
#define FEATURE_AUTO_RECOVERY       1      // 自动恢复功能
#define FEATURE_ERROR_LOG           1      // 错误日志记录

/* 电源监测 */
#define POWER_VOLTAGE_MIN           21.0f  // 最低工作电压(V)
#define POWER_VOLTAGE_CRITICAL      19.0f  // 临界电压(V)

/* 通信超时配置 */
#define RS485_TIMEOUT_MS            100    // 通信超时100ms
#define RS485_RETRY_COUNT           3      // 重试3次
#define RS485_RETRY_DELAY_MS        50     // 重试间隔50ms

/* 堵转检测 */
#define MOTOR_STALL_DETECTION       1      // 启用堵转检测
#define MOTOR_STALL_TIMEOUT_MS      3000   // 堵转超时3秒
```

#### 添加故障注入接口（motor_zdt.c）
```c
/**
 * @brief 故障注入接口（用于测试）
 * @param fault_type: 故障类型
 *        1 - 模拟通信超时
 *        2 - 模拟FIFO溢出
 *        3 - 模拟看门狗超时（死循环）
 *        4 - 模拟电机失步
 */
void inject_fault(uint8_t fault_type)
{
    printf("\n[FAULT INJECT] Type: %d\n", fault_type);
    
    switch (fault_type) {
        case 1:  // 通信超时
            printf("Injecting communication timeout...\n");
            HAL_Delay(200);  // 超过100ms超时设置
            break;
            
        case 2:  // FIFO溢出
            printf("Injecting FIFO overflow...\n");
            for (int i = 0; i < 300; i++) {
                emm_fifo_write(0xFF);  // 强制写入超出256字节
            }
            break;
            
        case 3:  // 看门狗超时（危险！）
            printf("Injecting watchdog timeout (DANGEROUS!)...\n");
            printf("System will reset in 2 seconds...\n");
            while(1);  // 死循环，触发看门狗复位
            break;
            
        case 4:  // 电机失步
            printf("Injecting motor mis-step...\n");
            // 发送错误的脉冲数
            Emm_V5_Pos_Control(MOTOR_ADDRESS, 0, 5000, 0, 100000, 0, 0);
            break;
            
        default:
            printf("Unknown fault type\n");
            break;
    }
}

/* 在usmart_config.c中注册 */
{(void *)inject_fault, "void inject_fault(uint8_t type)"},
```

---

## 🚀 测试执行步骤

### 测试项 T7.2.1: 电源跌落恢复测试（P0）

#### 测试目的
验证系统在电源电压波动时的容错能力，模拟工业现场电压不稳定情况。

#### 测试步骤

**Step 1: 正常工作基线建立（5分钟）**
```bash
1. 使用可调稳压电源供电，初始设置24.0V
2. 启动电机位置模式运动: motor_pos_move(1,0,300,10,3200)
3. 用万用表测量并记录稳态电流（预计0.8A-1.2A）
4. 确认电机运行平稳，日志无错误
```

**Step 2: 电压缓慢跌落测试**
```bash
测试点1: 23V（正常范围）
  1. 缓慢调低电源至23V（1秒内）
  2. 观察电机是否继续运行
  3. 记录日志是否有电压告警
  预期结果: 电机正常运行，无警告

测试点2: 22V（接近下限）
  1. 继续调低至22V
  2. 观察电机运行是否平稳
  预期结果: 电机正常运行，可能有轻微转速下降

测试点3: 21V（临界点）
  1. 调低至21V（设定的最低电压）
  2. 检查是否触发低压保护
  预期结果: 
     - 触发低压告警但继续运行
     - 日志输出"WARNING: Low voltage detected"

测试点4: 20V（低于下限）
  1. 调低至20V
  预期结果:
     - 触发保护，电机停止或失能
     - 日志输出"ERROR: Voltage too low, motor disabled"
```

**Step 3: 电压快速跌落测试（模拟瞬间断电）**
```bash
1. 电源设置回24V，电机正常运行
2. 准备秒表，快速将电源旋钮转至10V（<0.5秒）
3. 保持10V持续1秒
4. 快速恢复到24V
5. 观察系统反应:
   ✓ STM32是否复位（看LED闪烁模式）
   ✓ 电机是否停止
   ✓ 恢复后能否自动重新使能
6. 检查日志是否记录复位事件
```

**Step 4: 电压恢复后自动重启测试**
```bash
1. 电源完全断开5秒
2. 重新上电至24V
3. 观察系统是否自动初始化:
   ✓ LED0开始闪烁（心跳）
   ✓ 串口输出启动日志
   ✓ 电机自动使能（如配置了自动使能）
4. 手动发送命令测试功能恢复: motor_pos_move(1,0,300,10,3200)
```

#### 数据记录表

| 电压(V) | 电流(A) | 电机状态 | STM32状态 | 日志输出 | 结果 |
|---------|---------|----------|-----------|----------|------|
| 24.0 | 1.0 | 正常运行 | 正常 | 无 | Pass |
| 23.0 | 0.95 | 正常运行 | 正常 | 无 | Pass |
| 22.0 | 0.90 | 正常运行 | 正常 | 无 | Pass |
| 21.0 | 0.85 | 正常运行 | 正常 | "WARNING: Low voltage" | Pass |
| 20.0 | 0.80 | 停止 | 正常 | "ERROR: Voltage too low" | Pass |
| 10.0(1s) | - | 停止 | 复位 | "System Reboot" | Pass |

#### 验收标准
- [ ] 电压≥21V时系统正常运行
- [ ] 电压<21V时触发保护机制
- [ ] 电压恢复后能在10秒内恢复正常工作
- [ ] 无硬件损坏

---

### 测试项 T7.2.2: RS485通信断线重连测试（P0）

#### 测试目的
验证RS485通信中断后的恢复能力，模拟线缆松动、断线等场景。

#### 测试步骤

**Step 1: 通信正常基线（5分钟）**
```bash
1. 启动连续通信测试:
   start_auto_test(1)  # 位置模式自动测试
2. 观察日志输出通信成功率应为100%
3. 记录基线数据
```

**Step 2: A线断开测试**
```bash
1. 电机正在运行时，拔掉RS485的A线
2. 观察现象:
   ✓ 电机立即停止（失去通信）
   ✓ 日志输出"ERROR: Communication timeout"
   ✓ LED1停止闪烁或变为常亮（错误指示）
3. 保持断开状态30秒
4. 重新连接A线
5. 观察恢复过程:
   ✓ 是否自动重新通信
   ✓ 恢复时间（从连接到首次成功通信）
   ✓ 电机是否自动恢复运行（如配置了自动恢复）
6. 手动重启测试: start_auto_test(1)
```

**Step 3: B线断开测试（重复上述步骤）**
```bash
1. 拔掉RS485的B线
2. 观察与记录（同上）
3. 重新连接B线
4. 验证恢复功能
```

**Step 4: A/B线短接测试（危险！谨慎操作）**
```bash
⚠️ 注意: 此测试可能损坏RS485芯片，仅执行1次

1. 电机停止状态下操作
2. 用导线短接A-B两线（持续时间<1秒）
3. 观察:
   ✓ RS485模块是否冒烟或发热
   ✓ STM32是否继续运行
   ✓ 通信是否完全失效
4. 移除短接线
5. 测试通信是否恢复
   - 如恢复: 记录恢复时间
   - 如未恢复: 更换RS485模块重新测试
```

**Step 5: 通信线缆松动模拟**
```bash
1. 运行连续测试模式
2. 间歇性轻微拉扯RS485线缆（模拟松动）
3. 观察:
   ✓ 通信成功率是否下降
   ✓ 是否触发重试机制
   ✓ 电机运动是否受影响
4. 记录:
   - 触发重试的次数
   - 最终重试成功率
```

#### 数据记录表

| 故障类型 | 持续时间 | 恢复时间 | 自动恢复 | 重试次数 | 结果 |
|----------|----------|----------|----------|----------|------|
| A线断开 | 30s | 2.3s | 是 | 3 | Pass |
| B线断开 | 30s | 2.1s | 是 | 3 | Pass |
| A-B短接 | <1s | 5.0s | 是 | 失败后恢复 | Pass |
| 线缆抖动 | 2min | 实时 | 是 | 15次 | Pass |

#### 验收标准
- [ ] 单线断开后30秒内能恢复通信
- [ ] 短接后RS485模块无永久损坏
- [ ] 重试机制有效率>90%
- [ ] 抖动场景下成功率>95%

---

### 测试项 T7.2.3: 通信超时与重试机制测试（P1）

#### 测试目的
验证软件层面的通信超时检测和重试逻辑是否正确工作。

#### 测试步骤

**Step 1: 正常通信延迟测量**
```bash
1. 使用示波器或逻辑分析仪连接RS485总线
2. 发送单条命令: motor_pos_move(1,0,300,10,3200)
3. 测量:
   - 发送完成到接收响应的时间间隔
   - 典型值应为5-15ms
4. 重复10次，计算平均值和最大值
```

**Step 2: 软件注入超时**
```bash
# 使用故障注入接口
inject_fault(1)  # 注入通信超时

观察日志输出:
1. "Communication timeout detected"
2. "Retry 1/3..."
3. "Retry 2/3..."
4. "Retry 3/3..."
5. "Command failed after 3 retries"

验证点:
✓ 超时检测响应时间 < 150ms (100ms超时 + 50ms余量)
✓ 重试次数正好3次
✓ 每次重试间隔约50ms
✓ 最终失败后不再重试
```

**Step 3: 间歇性超时测试**
```bash
# 修改emm_uart.c模拟随机超时（测试固件）
static uint8_t random_fail_counter = 0;

uint8_t emm_uart_send_with_response(...) {
    random_fail_counter++;
    if (random_fail_counter % 10 == 0) {
        // 模拟10%的失败率
        return 0;  
    }
    // 正常发送...
}

测试步骤:
1. 编译并烧录测试固件
2. 运行100次连续命令
3. 统计:
   - 首次失败次数（应约10次）
   - 重试成功次数（应约9-10次）
   - 最终失败次数（应0-1次）
4. 计算整体成功率 = (100 - 最终失败次数) / 100
   目标: ≥99%
```

**Step 4: 极限超时测试**
```bash
1. 修改RS485_TIMEOUT_MS为20ms（极短）
2. 重新编译烧录
3. 运行正常命令
4. 观察是否频繁误触发超时
5. 如误触发>10%，说明超时设置不合理
6. 恢复RS485_TIMEOUT_MS为100ms
```

#### 验收标准
- [ ] 超时检测精度 ±10ms
- [ ] 重试机制触发正确
- [ ] 重试成功率>90%
- [ ] 无误触发超时（正常通信下）

---

### 测试项 T7.2.4: 电机堵转保护测试（P0）

#### 测试目的
验证电机在机械堵转情况下的保护机制，防止烧毁电机或驱动器。

#### ⚠️ 危险警告
```
【高风险操作】
- 堵转会产生大电流和高温
- 堵转时间不得超过5秒
- 必须持续监测电机温度
- 准备急停开关
- 测试次数不超过3次/天
```

#### 测试步骤

**Step 1: 空载运行基线**
```bash
1. 电机无负载运行
2. 测量并记录:
   - 24V电源电流: 约0.8-1.2A
   - 电机外壳温度: 约40-50°C
   - 运动时间: 转1圈约600ms
```

**Step 2: 轻度负载测试**
```bash
1. 在电机轴上安装轻飞轮（惯性负载）
2. 执行相同运动
3. 观察:
   ✓ 电流是否增加（应为1.5-2.0A）
   ✓ 运动时间是否延长（可能800ms）
   ✓ 电机是否仍能完成运动
```

**Step 3: 堵转测试（关键步骤）**
```bash
准备工作:
1. 准备木块或手套（用于阻挡电机轴）
2. 启动秒表
3. 手放在急停开关上

执行步骤:
1. 发送运动命令: motor_pos_move(1,0,300,10,3200)
2. 电机开始转动后立即用木块卡住电机轴（完全堵转）
3. 同时启动秒表
4. 观察:
   ✓ 电机是否发出异响
   ✓ 电流表读数（应快速上升至2.5-3.0A）
   ✓ 电机驱动器是否有保护指示灯
   ✓ STM32日志是否输出堵转告警
   ✓ 电机是否在3秒内自动停止

5. 如5秒后仍未保护，立即按急停！

6. 松开木块，等待电机冷却2分钟

7. 记录:
   - 堵转检测时间
   - 保护动作是否正确
   - 电机最终温度
```

**Step 4: 堵转恢复测试**
```bash
1. 堵转保护触发后，等待30秒
2. 手动重新使能电机: motor_enable(1,1)
3. 再次发送运动命令
4. 验证:
   ✓ 电机能否正常运行
   ✓ 是否有永久损伤（异响、抖动）
```

**Step 5: 编码器反馈验证（如有编码器）**
```bash
1. 发送命令转1圈(3200脉冲)
2. 中途堵转2秒
3. 松开后继续运动
4. 查询电机编码器位置
5. 验证:
   - 实际位置是否与预期一致
   - 如不一致，记录偏差值（失步量）
```

#### 数据记录表

| 测试轮次 | 堵转时间 | 检测延迟 | 最大电流 | 最高温度 | 保护动作 | 恢复状态 | 结果 |
|----------|----------|----------|----------|----------|----------|----------|------|
| 1 | 3s | 2.8s | 2.8A | 65°C | 正常停止 | 完全恢复 | Pass |
| 2 | 2s | 1.9s | 2.7A | 62°C | 正常停止 | 完全恢复 | Pass |
| 3 | 5s | 4.2s | 3.0A | 72°C | 正常停止 | 有轻微抖动 | Warning |

#### 验收标准
- [ ] 堵转检测时间<3秒
- [ ] 保护动作正确（电机停止或失能）
- [ ] 电机温度<80°C
- [ ] 恢复后功能正常
- [ ] 无硬件永久损坏

---

### 测试项 T7.2.5: 看门狗复位测试（P1）

#### 测试目的
验证IWDG看门狗能正确检测程序死机并自动复位系统。

#### 测试步骤

**Step 1: 看门狗参数确认**
```c
// 检查iwdg.c中的配置
IWDG_InitTypeDef hiwdg;
hiwdg.Prescaler = IWDG_PRESCALER_64;  // 64分频
hiwdg.Reload = 1250;                  // 重载值

// 计算超时时间:
// T = (Prescaler / 32kHz) * Reload
// T = (64 / 32000) * 1250 = 2.5秒
```

**Step 2: 正常喂狗验证**
```bash
1. 系统正常运行
2. 在main()主循环中确认有喂狗代码:
   #if FEATURE_WATCHDOG_ENABLE
       iwdg_feed();
   #endif
3. 观察系统能持续运行>10分钟无复位
```

**Step 3: 触发看门狗复位（软件方法）**
```bash
# 通过串口发送命令
inject_fault(3)  # 注入看门狗超时故障

观察:
1. 日志输出: "Injecting watchdog timeout..."
2. 系统在2秒后无任何响应
3. 2秒后系统自动复位
4. 重启日志输出: "!!! IWDG Reset Detected !!!"
5. 系统恢复正常运行

计时验证:
- 从inject_fault(3)到复位的时间应为2.0±0.2秒
```

**Step 4: 触发看门狗复位（硬件方法）**
```bash
1. 修改main.c，注释掉喂狗代码:
   // iwdg_feed();  // 暂时屏蔽
2. 重新编译烧录
3. 观察系统每2秒自动复位一次
4. 串口会循环输出启动日志
5. 恢复喂狗代码，重新编译
```

**Step 5: 看门狗复位计数测试**
```bash
1. 使用inject_fault(3)触发复位5次
2. 检查复位计数器:
   每次复位后日志应输出:
   "Watchdog Resets: 1"
   "Watchdog Resets: 2"
   ...
   "Watchdog Resets: 5"
3. 验证计数器在断电后是否保持（如使用RTC备份寄存器）
```

#### 数据记录表

| 测试次数 | 触发方式 | 复位延迟 | 恢复时间 | 计数器值 | 结果 |
|----------|----------|----------|----------|----------|------|
| 1 | inject_fault(3) | 2.1s | 1.5s | 1 | Pass |
| 2 | inject_fault(3) | 2.0s | 1.4s | 2 | Pass |
| 3 | 注释喂狗代码 | 2.0s | 循环复位 | - | Pass |

#### 验收标准
- [ ] 看门狗超时时间精度±10%
- [ ] 复位后系统能正常恢复
- [ ] 复位计数器工作正常
- [ ] 复位标志位能正确检测

---

## 📊 综合压力测试（可选）

### 多故障并发测试

**场景设计**: 同时注入多个故障，测试极限情况

```bash
测试步骤:
1. 启动48h自动测试模式
2. 运行1小时后，执行以下故障序列:
   T+0s:  拔掉RS485 A线
   T+10s: 重新连接A线
   T+20s: 电源降至21V
   T+30s: 恢复24V
   T+40s: 堵转电机2秒
   T+50s: inject_fault(1) 软件超时
3. 观察系统能否在所有故障后恢复正常
4. 检查日志中所有故障是否都被记录
```

### 循环疲劳测试

```bash
测试步骤:
1. 编写脚本自动循环执行T7.2.1-T7.2.5
2. 每个测试项执行5轮
3. 总耗时约4小时
4. 统计:
   - 总故障注入次数
   - 恢复成功次数
   - 恢复失败次数
   - 平均恢复时间
5. 目标: 恢复成功率>95%
```

---

## ✅ 测试完成检查清单

### 必须完成的测试项
- [ ] T7.2.1 电源跌落恢复测试
- [ ] T7.2.2 RS485断线重连测试
- [ ] T7.2.4 电机堵转保护测试

### 建议完成的测试项
- [ ] T7.2.3 通信超时与重试测试
- [ ] T7.2.5 看门狗复位测试

### 测试交付物
- [ ] 故障注入测试记录表（Excel）
- [ ] 测试视频/照片（关键场景）
- [ ] 异常日志文件
- [ ] 改进建议报告

---

## 🔍 常见问题处理

### Q1: 电源跌落后STM32复位但电机不恢复
**A**: 需要在复位检测后手动重新使能电机
```c
if (__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST) != RESET) {
    HAL_Delay(100);
    Emm_V5_En_Control(MOTOR_ADDRESS, 1, 0);  // 自动重新使能
}
```

### Q2: 堵转测试后电机有异响
**A**: 可能是轴承损伤，更换电机；降低测试频率，每次堵转时间<3秒

### Q3: RS485断线后不能自动恢复
**A**: 检查重试逻辑是否正确实现，增加日志输出调试

---

**文档结束 | 下一步: 阅读 `V3.5-Phase7-03-通信压力测试.md`**
