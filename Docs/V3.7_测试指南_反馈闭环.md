# V3.7 反馈闭环系统 - 测试指南

**版本**: V3.7  
**日期**: 2025-12-03  
**状态**: ✅ 已编译并烧录成功

---

## 系统架构升级

### 新增功能

1. **响应帧解析器** (`emm_v5_parser.c/h`)
   - 零拷贝高性能解析
   - 支持S_CPOS（位置）、S_VEL（速度）、S_FLAG（状态标志）
   - 统计功能：总帧数、有效帧数、校验错误数

2. **电机监控系统** (`motor_monitor.c/h`)
   - 非阻塞异步架构（执行时间<1ms）
   - 自动在线检测（1秒无响应=离线）
   - 周期位置同步（200ms查询S_CPOS）
   - 周期状态检查（500ms查询S_FLAG）
   - 堵转自动检测

3. **主循环集成** (`app_tasks.c`)
   - 新增 `task_motor_monitor()` 任务
   - 自动处理响应帧（`motor_monitor_process_response()`）
   - 保持高速实时性能（10kHz TIM2不受影响）

### 内存占用

```
Flash: 44032 bytes (67.2% of 64KB)  ← +2.6KB (V3.6: 41.4KB)
RAM:   约5.8KB (29% of 20KB)        ← +0.5KB (新增336B监控数据)
```

---

## 测试步骤

### 步骤1：查看启动日志

**预期输出**：
```
[USART2] DMA TX configured (Channel 7, Priority=VeryHigh)
[USART2] DMA RX configured (Channel 6, Circular 512B, CPU saving 95%)

========================================
  STM32F103 Motor Control System V3.0  
========================================
System Clock:   72 MHz
APB1 Clock:     36 MHz
APB2 Clock:     72 MHz
Compile Date:   Dec  3 2025 02:XX:XX
Architecture:   V3.0 (3-Layer Design)
========================================

[RT_MOTOR] Dynamic command build (saves 30KB RAM, +5us latency)
[RT_MOTOR] Initialized. DMA=1, Queue=32, Tick=100us
[RT_MOTOR] Real-Time Motor System Initialized
[RT_MOTOR] Target Latency: <10us, Queue: 32 cmds
[TIM2] Real-Time Timer Started (10kHz, 100us period)

[Printer] 3-Axis 4-Motor System Init
  X-Axis: Motor 0x01 (Width)
  Y-Axis: Motor 0x02 + 0x03 (Depth, Sync)
  Z-Axis: Motor 0x04 (Height)
[Printer] Auto-enabling all motors...
[EMM_UART] TX 6 bytes: 00 F3 AB 01 00 6B 
[Printer] All axes enabled
[Printer] Initialization complete

✨ [MONITOR] Motor monitor initialized
✨ [MONITOR] Registered motor 0x01
✨ [MONITOR] Registered motor 0x02
✨ [MONITOR] Registered motor 0x03
✨ [MONITOR] Registered motor 0x04
✨ [V3.7] Motor feedback system enabled

[TASKS] Initialized
USMART Initialized
Type 'printer_show_status()' to view system status
```

### 步骤2：查看电机在线状态（关键测试）

**执行命令**：
```
motor_monitor_status()
```

**预期输出（只连接X轴电机）**：
```
========== Motor Monitor Status ==========
Registered motors: 4

Motor 0x01:
  Online: YES                    ← ✅ X轴在线
  Cmd Pos: 0
  Real Pos: 0 
  Error: 0
  Velocity: 0 RPM
  Enabled: YES
  Homed: NO
  Clogged: NO
  Success: 10, Timeout: 0        ← 查询成功计数

Motor 0x02:
  Online: NO                     ← ✅ Y轴左侧离线（未连接）
  Offline for 1200 ms

Motor 0x03:
  Online: NO                     ← ✅ Y轴右侧离线（未连接）
  Offline for 1200 ms

Motor 0x04:
  Online: NO                     ← ✅ Z轴离线（未连接）
  Offline for 1200 ms

==========================================
```

**关键验证点**：
- ✅ X轴显示 `Online: YES`（有电机）
- ✅ Y/Z轴显示 `Online: NO`（无电机）
- ✅ 不再"自以为"Y/Z已使能

### 步骤3：测试位置反馈

**执行命令**：
```
printer_move_x(3200,800)        # X轴移动1圈
HAL_Delay(2000)                 # 等待2秒（运动完成+位置查询）
motor_monitor_status()          # 查看真实位置
```

**预期输出**：
```
Motor 0x01:
  Online: YES
  Cmd Pos: 3200                  ← 命令位置（软件记录）
  Real Pos: 3200                 ← 真实位置（编码器反馈）✅
  Error: 0                       ← 位置误差=0（完美）
  Velocity: 0 RPM
  Success: 25, Timeout: 0
```

**如果电机失步（测试异常情况）**：
```
Motor 0x01:
  Cmd Pos: 3200
  Real Pos: 3150                 ← 真实位置少了50脉冲
  Error: 50                      ← ✅ 检测到误差
  [WARN] Motor 0x01: Large pos error 50  ← ✅ 自动告警
```

### 步骤4：测试多次移动的位置累积

**执行命令**：
```
printer_move_x(3200,800)        # 第1次
HAL_Delay(2000)
printer_move_x(1600,800)        # 第2次
HAL_Delay(2000)
motor_monitor_status()
```

**预期输出**：
```
Motor 0x01:
  Cmd Pos: 4800                  ← 3200+1600=4800 ✅
  Real Pos: 4800                 ← 编码器确认
  Error: 0
```

### 步骤5：测试堵转检测（手动阻挡电机）

**操作**：
1. 执行 `printer_move_x(9600,500)`（转3圈）
2. **用手阻挡电机转动**（模拟堵转）
3. 观察串口输出

**预期输出**：
```
[ERROR] Motor 0x01: CLOGGED detected! Count=1  ← ✅ 自动检测堵转
Motor 0x01:
  Cmd Pos: 9600
  Real Pos: 2500                 ← 只转了部分
  Error: 7100                    ← ✅ 巨大误差
  Clogged: YES                   ← ✅ 状态标志位
```

### 步骤6：测试Y/Z轴离线保护

**执行命令**：
```
printer_move_y(1600,600)
```

**预期输出**：
```
[EMM_UART] TX 13 bytes: 02 FD ...  ← 命令发送
[EMM_UART] TX 13 bytes: 03 FD ...  
[EMM_UART] TX 4 bytes: 00 FF ...   ← 同步触发

# 1秒后自动检测超时
[WARN] Motor 0x02: OFFLINE (timeout 1000 ms)  ← ✅ 自动检测离线
[WARN] Motor 0x03: OFFLINE (timeout 1000 ms)
```

**关键点**：
- ✅ 命令正常发送（不阻塞）
- ✅ 1秒后自动标记离线
- ✅ 不会"自以为"Y轴已移动

---

## 新增USMART命令

### `motor_monitor_status()`
显示所有电机的监控状态（在线/离线/位置/速度/堵转）

**使用场景**：
- 启动后检查电机连接
- 调试位置偏差问题
- 监控堵转情况

---

## 性能验证

### 实时性测试

**测试方法**：示波器测量TIM2中断周期

**预期结果**：
- TIM2周期：100μs ±1% ✅（不受motor_monitor影响）
- motor_monitor_task()执行时间：<500μs
- 主循环周期：<2ms（V3.6: 1.5ms → V3.7: 1.8ms，增加0.3ms可接受）

### 通信负载

**200ms位置查询 + 500ms状态查询**：
- 查询命令：3字节/次
- 响应帧：7字节（位置）+ 4字节（状态）
- 总流量：约150字节/秒（115200bps的0.13%，完全可忽略）

---

## 常见问题排查

### 问题1：所有电机显示离线

**可能原因**：
1. RS485连接错误（A-B线接反）
2. 电机地址不匹配
3. 波特率错误

**检查方法**：
```
motor_move_x(3200,800)          # 手动发送命令
# 观察 [EMM_UART] TX日志，确认命令发送
```

### 问题2：位置误差持续增大

**可能原因**：
1. 电机失步（负载过大）
2. 编码器故障
3. 电源电压不足

**检查方法**：
```
motor_monitor_status()          # 查看Error字段
# Error > 100脉冲 → 异常
```

### 问题3：motor_monitor_status()无响应

**可能原因**：
1. USART1串口未连接
2. printf缓冲区满（输出过多）

**解决方法**：
```
# 重启STM32
# 或执行简单命令测试USART1
printer_show_status()
```

---

## 下一步优化方向

### Phase 2（可选）：自动重试机制
```c
if (motor->timeout_count > 3) {
    // 自动重新查询
    motor_monitor_query_position_now(motor->addr);
}
```

### Phase 3（可选）：位置校准
```c
if (motor->position_error > 50) {
    // 自动同步命令位置=真实位置
    motor->cmd_position = motor->real_position;
}
```

### Phase 4（可选）：堵转恢复
```c
if (motor->status.is_clogged) {
    // 自动反转解除堵转
    Emm_V5_Vel_Control(motor->addr, 1, 100, 10, false);
    HAL_Delay(500);
    Emm_V5_Stop_Now(motor->addr, false);
}
```

---

## 成功标准

- ✅ X轴在线检测准确（Online=YES）
- ✅ Y/Z轴离线检测准确（Online=NO）
- ✅ 位置反馈与命令一致（Error=0）
- ✅ 堵转自动检测（Clogged=YES）
- ✅ TIM2实时性不受影响（100μs周期稳定）
- ✅ 系统不再重启（看门狗已禁用）

---

**测试负责人**: [待填写]  
**测试日期**: 2025-12-03  
**测试结果**: [待填写]
