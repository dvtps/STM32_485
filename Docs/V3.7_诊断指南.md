# V3.7 电机在线检测诊断指南

**版本**: V3.7  
**日期**: 2025-12-03

---

## 当前在线检测机制

### 判定在线条件 ✅

```c
/* 仅在成功接收并解析响应帧时判定在线 */
motor->online = true;
```

**触发路径**：
1. USART2 IDLE中断接收完整帧
2. `motor_monitor_process_response()` 调用 `emm_parser_parse()` 解析
3. 解析成功 + 校验和通过 + 地址匹配 → 设置 `online = true`

### 判定离线条件 ❌

```c
/* 每次主循环检查：距离上次响应 > 1000ms */
if (motor->online && elapsed > MOTOR_ONLINE_TIMEOUT_MS) {
    motor->online = false;
}
```

**触发路径**：
1. `check_motor_timeout()` 在 `motor_monitor_task()` 中每次主循环调用
2. `HAL_GetTick() - motor->last_response_tick > 1000` → 设置 `online = false`

---

## 诊断方法

### 方法1：启用详细日志（推荐）

**修改 `app_config.h`**:
```c
#define MOTOR_MONITOR_DEBUG         1  /* 0→1 启用调试日志 */
```

**重新编译烧录后，预期日志**:
```
========================================
[V3.7] Motor feedback system enabled

/* 初始化时发送查询 */
[EMM_UART] TX 3 bytes: 01 36 6B    ← 查询电机0x01位置
[EMM_UART] TX 3 bytes: 02 36 6B
[EMM_UART] TX 3 bytes: 03 36 6B
[EMM_UART] TX 3 bytes: 04 36 6B

/* 如果电机0x01在线，会看到响应 */
[EMM_UART] RX 7 bytes: 01 36 00 00 00 00 6B  ← ✅ 收到响应
[MONITOR] Motor 0x01 is now ONLINE (first response received)

/* 如果电机0x02/0x03/0x04离线 */
[WARN] Motor 0x02: OFFLINE (timeout 1000 ms)  ← 1秒后自动检测
[WARN] Motor 0x03: OFFLINE (timeout 1000 ms)
[WARN] Motor 0x04: OFFLINE (timeout 1000 ms)

/* 离线电机降级为5秒轮询一次 */
[EMM_UART] TX 3 bytes: 01 3A 6B    ← 只查询在线电机（500ms周期）
[EMM_UART] RX 4 bytes: 01 3A XX 6B ← 收到状态响应
```

### 方法2：手动测试单个电机

**在串口助手执行**:
```
motor_monitor_query_position_now(1)   # 强制查询电机0x01位置
HAL_Delay(100)                        # 等待100ms
motor_monitor_status()                # 查看在线状态
```

**预期输出（电机在线）**:
```
Motor 0x01:
  Online: YES                          ← ✅ 确认在线
  Cmd Pos: 0
  Real Pos: 0                          ← 真实位置=0（初始状态）
  Success: 1, Timeout: 0               ← 成功查询1次
```

**预期输出（电机离线）**:
```
Motor 0x01:
  Online: NO                           ← ❌ 确认离线
  Offline for 1200 ms                  ← 1.2秒无响应
  Success: 0, Timeout: 3               ← 超时3次
```

---

## 可能的问题场景

### 场景1：电机有响应，但判定离线

**症状**：
```
[EMM_UART] TX 3 bytes: 01 36 6B      ← 发送查询
[EMM_UART] RX 7 bytes: 01 36 ...     ← 收到响应
[WARN] Motor 0x01: OFFLINE           ← 但仍然离线？
```

**可能原因**：
1. 响应帧校验和错误 → `emm_parser_parse()` 返回 false
2. 响应帧格式错误 → 帧长度不匹配
3. 电机地址不匹配 → `find_motor_by_addr()` 返回 NULL

**排查方法**：
```c
/* 在 motor_monitor.c 的 motor_monitor_process_response() 添加日志 */
printf("[DEBUG] Parse result: %s, addr=0x%02X, len=%u\r\n", 
       parsed ? "OK" : "FAIL", response.motor_addr, len);
```

### 场景2：电机无响应

**症状**：
```
[EMM_UART] TX 3 bytes: 01 36 6B      ← 发送查询
/* 无任何 RX 日志 */
[WARN] Motor 0x01: OFFLINE (timeout 1000 ms)
```

**可能原因**：
1. RS485连接错误（A-B线接反或未连接）
2. 电机地址不是0x01
3. 电机未上电
4. 波特率不匹配（当前115200bps）
5. USART2 IDLE中断未触发

**排查方法**：
- 检查硬件：用示波器/逻辑分析仪监测RS485总线
- 检查地址：用电机上位机确认地址设置
- 检查接线：A-A, B-B（不要接反）
- 测试回环：短接USART2 TX-RX，测试发送=接收

### 场景3：初始化时查询一次，后续不再查询

**症状**：
```
[EMM_UART] TX 3 bytes: 01 36 6B      ← 只在启动时发送一次
/* 后续完全没有查询 */
```

**可能原因**：
1. `motor_monitor_task()` 未被调用
2. 电机未注册（`motor_monitor_register()` 失败）
3. 主循环卡死

**排查方法**：
```c
/* 在 motor_monitor_task() 开头添加心跳日志 */
static uint32_t call_count = 0;
if (++call_count % 1000 == 0) {  /* 每1000次打印一次 */
    printf("[MONITOR] Task heartbeat: %lu\r\n", call_count);
}
```

---

## 确认在线的黄金标准

### 标准1：收到任意有效响应帧

```c
/* 只要收到以下任一响应，即可确认在线 */
- 0x36: S_CPOS 位置响应（7字节）
- 0x3A: S_FLAG 状态响应（4字节）
- 0x35: S_VEL  速度响应（5字节）
- 0x37: S_PERR 位置误差响应（7字节）
```

### 标准2：响应帧必须通过校验

```c
/* 所有响应帧末尾固定为 0x6B */
uint8_t checksum = rx_data[len - 1];
if (checksum != 0x6B) {
    return false;  /* 校验失败，不认为在线 */
}
```

### 标准3：1秒内至少1次响应

```c
/* 200ms查询位置 + 500ms查询状态 = 1秒内至少2次查询 */
/* 如果2次查询都无响应，1秒后判定离线 */
if (HAL_GetTick() - motor->last_response_tick > 1000) {
    motor->online = false;
}
```

---

## 推荐诊断流程

### 第1步：启用调试日志
```c
/* app_config.h */
#define MOTOR_MONITOR_DEBUG         1
```

### 第2步：编译烧录
```powershell
cmake --build --preset Debug
pyocd flash -t stm32f103c8 build/Debug/STM32_485.elf
```

### 第3步：观察串口输出
**重点关注**：
1. `[EMM_UART] RX` 日志是否出现
2. `[MONITOR] Motor 0x0X is now ONLINE` 日志
3. `[WARN] Motor 0x0X: OFFLINE` 日志

### 第4步：执行手动测试
```
motor_monitor_status()              # 查看当前状态
motor_monitor_query_position_now(1) # 强制查询
HAL_Delay(200)
motor_monitor_status()              # 再次查看状态
```

### 第5步：分析结果
- **有 RX 日志 + Online=YES** → ✅ 在线检测正常
- **有 RX 日志 + Online=NO**  → ⚠️ 解析失败或地址不匹配
- **无 RX 日志**              → ❌ 硬件连接问题或电机未响应

---

## 常见问题FAQ

### Q1: 为什么启动时疯狂发送查询？
**A**: 因为4台电机都注册了，每台500ms查询一次，看起来像高频轮询。  
**解决方案**: 已在V3.7优化，离线电机降级为5秒查询一次。

### Q2: 如何只监控已连接的电机？
**A**: 启动后等待5秒，系统自动检测离线电机并停止轮询。  
**或者**: 只注册实际连接的电机（修改 `main.c` 的 `motor_monitor_register()` 调用）。

### Q3: 电机在线判定需要多久？
**A**: 最快200ms（收到首次位置查询响应），最慢1秒（无响应判定离线）。

### Q4: 如何手动标记电机离线？
**A**: 调用 `motor_monitor_unregister(addr)` 取消监控。

### Q5: 日志太多影响性能吗？
**A**: 启用 `MOTOR_MONITOR_DEBUG=1` 会增加约500μs主循环延迟，建议仅调试时使用。

---

## 总结

**当前在线检测机制是可靠的**，判定标准明确：
- ✅ 收到有效响应帧 → 在线
- ❌ 1秒无响应 → 离线
- 🔄 离线后5秒轮询一次（检测重新上线）

**下一步调试**：
1. 启用 `MOTOR_MONITOR_DEBUG=1`
2. 观察是否有 `[EMM_UART] RX` 日志
3. 根据日志判断是硬件问题还是软件问题
