# 06 - 多机通讯

[← 上一章：回零功能](05-回零功能.md) | [返回目录](README.md) | [下一章：STM32集成指南 →](07-STM32集成指南.md)

---

## 6.1 多机通讯概述

Y系列电机支持在同一条RS485总线上连接多达**255台电机**，通过地址区分实现多机控制。

**优势**:
- ✅ 节省MCU串口资源（1个串口控制多台电机）
- ✅ 简化接线（菊花链并联）
- ✅ 支持同步运动（多轴协同）
- ✅ 长距离通信（RS485最远1200米）

---

## 6.2 硬件连接

### 6.2.1 RS485菊花链接线

```
MCU(STM32)         RS485模块
  USART2_TX ───→ TX
  USART2_RX ←─── RX
  GND       ───→ GND
                   A  ───┬───┬───┬─── (总线A)
                   B  ───┼───┼───┼─── (总线B)
                   
                       电机1  电机2  电机N
                       A──┘   │      │
                       B──────┘      │
                      GND────────────┘
```

**接线要点**:
1. 所有电机的 A、B、GND 并联连接
2. 总线两端（首尾）接120Ω终端电阻（A-B之间）
3. 推荐使用屏蔽双绞线
4. 总线长度 > 100米时必须加终端电阻

---

### 6.2.2 终端电阻安装

```
第一台电机                        最后一台电机
  A ─────120Ω─────┐              A ─────120Ω─────┐
  B ───────────────┘              B ───────────────┘
  
注：中间电机不需要终端电阻
```

**作用**: 消除信号反射，提高通信可靠性

---

## 6.3 电机地址设置

### 6.3.1 地址规则

| 地址值 | 用途 | 说明 |
|-------|------|------|
| **1~255** | 单机地址 | 每台电机的唯一标识 |
| **0** | 广播地址 | 所有电机同时响应 |

**重要**: 同一总线上每台电机的地址必须唯一！

---

### 6.3.2 地址设置方法

**方法1: 出厂默认地址**
- 所有电机出厂地址为 **1**
- 多机组网前需先修改地址

**方法2: 通过上位机软件设置**
（需查阅电机配套上位机软件说明）

**方法3: 单独供电逐个设置**
```c
// 步骤：
// 1. 只给电机1供电，发送设置命令（假设有此命令）
// 2. 断电电机1，给电机2供电，设置为地址2
// 3. 重复直到所有电机地址配置完成
```

---

## 6.4 多机独立控制

### 6.4.1 基本控制

通过指定不同地址，独立控制各个电机：

```c
void multi_motor_independent_control(void)
{
    // 初始化RS485
    atk_rs485_init(115200);
    delay_ms(100);
    
    // 使能所有电机（广播）
    Emm_V5_En_Control(0, true, false);
    delay_ms(100);
    
    // 控制1号电机：顺时针转1圈
    Emm_V5_Pos_Control(1, 0, 1000, 20, 3200, false, false);
    delay_ms(100);
    
    // 控制2号电机：逆时针转2圈
    Emm_V5_Pos_Control(2, 1, 1000, 20, 6400, false, false);
    delay_ms(100);
    
    // 控制3号电机：以500RPM速度旋转
    Emm_V5_Vel_Control(3, 0, 500, 20, false);
    delay_ms(100);
}
```

---

### 6.4.2 广播命令

地址为 `0` 的命令会被所有电机接收：

```c
// 广播使能（所有电机同时使能）
Emm_V5_En_Control(0, true, false);

// 广播紧急停止（所有电机同时停止）
Emm_V5_Stop_Now(0, false);

// 广播失能（所有电机同时失能）
Emm_V5_En_Control(0, false, false);
```

⚠️ **注意**: 广播命令不会有响应帧返回

---

## 6.5 多机同步运动

### 6.5.1 同步运动原理

通过两步完成同步启动：
1. 发送带 `snF=true` 的命令给各个电机（命令缓存，不立即执行）
2. 发送同步触发命令（广播地址0），所有电机同时启动

```
时间轴:
  │
  ├─→ 发送命令1 (snF=true, 电机1准备)
  ├─→ 发送命令2 (snF=true, 电机2准备)
  ├─→ 发送命令3 (snF=true, 电机3准备)
  │
  ├─→ 发送同步触发 (广播地址0)
  │
  └─→ [所有电机同时启动]
```

---

### 6.5.2 同步位置控制

**示例：XY平台同步运动**

```c
void xy_platform_sync_move(int32_t x_pulse, int32_t y_pulse)
{
    // X轴电机地址=1，Y轴电机地址=2
    
    // 步骤1: 发送X轴命令（snF=true，不立即执行）
    uint8_t x_dir = (x_pulse >= 0) ? 0 : 1;
    Emm_V5_Pos_Control(1, x_dir, 1000, 20, abs(x_pulse), false, true);
    delay_ms(10);
    
    // 步骤2: 发送Y轴命令（snF=true，不立即执行）
    uint8_t y_dir = (y_pulse >= 0) ? 0 : 1;
    Emm_V5_Pos_Control(2, y_dir, 1000, 20, abs(y_pulse), false, true);
    delay_ms(10);
    
    // 步骤3: 触发同步启动（广播地址0）
    Emm_V5_Synchronous_motion(0);
    
    // XY两轴同时启动，保持同步运动
}

// 使用示例
xy_platform_sync_move(3200, 6400);  // X移动1圈，Y移动2圈，同时启动
```

---

### 6.5.3 多轴复杂运动

**示例：三轴机械臂同步控制**

```c
void robot_arm_sync_move(void)
{
    // 关节1: 地址1, 转动90度
    uint32_t joint1_pulse = degree_to_pulse(90.0);
    Emm_V5_Pos_Control(1, 0, 800, 20, joint1_pulse, false, true);
    delay_ms(10);
    
    // 关节2: 地址2, 转动45度
    uint32_t joint2_pulse = degree_to_pulse(45.0);
    Emm_V5_Pos_Control(2, 1, 800, 20, joint2_pulse, false, true);
    delay_ms(10);
    
    // 关节3: 地址3, 转动30度
    uint32_t joint3_pulse = degree_to_pulse(30.0);
    Emm_V5_Pos_Control(3, 0, 800, 20, joint3_pulse, false, true);
    delay_ms(10);
    
    // 同步触发，三个关节同时运动
    Emm_V5_Synchronous_motion(0);
    
    printf("机械臂正在同步运动...\n");
}
```

---

### 6.5.4 同步速度控制

```c
void multi_motor_sync_speed(void)
{
    // 电机1: 1000RPM, 同步标志
    Emm_V5_Vel_Control(1, 0, 1000, 20, true);
    delay_ms(10);
    
    // 电机2: 1500RPM, 同步标志
    Emm_V5_Vel_Control(2, 0, 1500, 20, true);
    delay_ms(10);
    
    // 电机3: 800RPM, 同步标志
    Emm_V5_Vel_Control(3, 0, 800, 20, true);
    delay_ms(10);
    
    // 触发同步启动
    Emm_V5_Synchronous_motion(0);
}
```

---

### 6.5.5 同步停止

```c
void multi_motor_sync_stop(void)
{
    // 方法1: 使用同步标志的停止命令
    Emm_V5_Stop_Now(1, true);
    delay_ms(10);
    Emm_V5_Stop_Now(2, true);
    delay_ms(10);
    Emm_V5_Stop_Now(3, true);
    delay_ms(10);
    Emm_V5_Synchronous_motion(0);  // 同步触发停止
    
    // 方法2: 广播立即停止（更快）
    Emm_V5_Stop_Now(0, false);  // 所有电机立即停止
}
```

---

## 6.6 通信时序管理

### 6.6.1 命令间隔

多机控制时需要留出足够的命令间隔：

```c
// 推荐间隔：10~50ms
Emm_V5_Pos_Control(1, 0, 1000, 20, 3200, false, false);
delay_ms(10);  // ← 命令间隔

Emm_V5_Pos_Control(2, 0, 1000, 20, 3200, false, false);
delay_ms(10);  // ← 命令间隔
```

**原因**: 
- RS485半双工通信，发送和接收不能同时进行
- 电机需要时间处理命令并返回响应

---

### 6.6.2 响应处理

在多机通信中，如果需要接收响应：

```c
void multi_motor_with_response(void)
{
    // 发送命令给电机1
    Emm_V5_Read_Sys_Params(1, S_CPOS);
    delay_ms(50);  // 等待响应
    
    if(rxFrameFlag)
    {
        // 处理电机1的响应
        process_motor_response(1, rxCmd, rxCount);
        rxFrameFlag = false;
    }
    
    // 发送命令给电机2
    Emm_V5_Read_Sys_Params(2, S_CPOS);
    delay_ms(50);  // 等待响应
    
    if(rxFrameFlag)
    {
        // 处理电机2的响应
        process_motor_response(2, rxCmd, rxCount);
        rxFrameFlag = false;
    }
}
```

---

## 6.7 实际应用案例

### 案例1: XY绘图机

```c
typedef struct {
    int32_t x;
    int32_t y;
} Point_t;

void draw_line(Point_t start, Point_t end)
{
    // 计算运动增量
    int32_t dx = end.x - start.x;
    int32_t dy = end.y - start.y;
    
    // 确定方向
    uint8_t x_dir = (dx >= 0) ? 0 : 1;
    uint8_t y_dir = (dy >= 0) ? 0 : 1;
    
    // 同步运动到目标点
    Emm_V5_Pos_Control(1, x_dir, 1000, 20, abs(dx), false, true);  // X轴
    delay_ms(10);
    Emm_V5_Pos_Control(2, y_dir, 1000, 20, abs(dy), false, true);  // Y轴
    delay_ms(10);
    Emm_V5_Synchronous_motion(0);  // 同步启动
    
    // 等待运动完成
    delay_ms(calculate_motion_time(abs(dx) > abs(dy) ? abs(dx) : abs(dy)));
}

// 绘制矩形
void draw_rectangle(void)
{
    Point_t p1 = {0, 0};
    Point_t p2 = {3200, 0};      // 向右1圈
    Point_t p3 = {3200, 3200};   // 向上1圈
    Point_t p4 = {0, 3200};      // 向左1圈
    
    draw_line(p1, p2);
    draw_line(p2, p3);
    draw_line(p3, p4);
    draw_line(p4, p1);
}
```

---

### 案例2: 四轴并联机器人

```c
void delta_robot_move(float x, float y, float z)
{
    // 逆运动学计算（简化示例）
    uint32_t motor1_pulse = calculate_motor1_pulse(x, y, z);
    uint32_t motor2_pulse = calculate_motor2_pulse(x, y, z);
    uint32_t motor3_pulse = calculate_motor3_pulse(x, y, z);
    uint32_t motor4_pulse = calculate_motor4_pulse(x, y, z);
    
    // 四轴同步运动命令
    Emm_V5_Pos_Control(1, 0, 1500, 30, motor1_pulse, false, true);
    delay_ms(10);
    Emm_V5_Pos_Control(2, 0, 1500, 30, motor2_pulse, false, true);
    delay_ms(10);
    Emm_V5_Pos_Control(3, 0, 1500, 30, motor3_pulse, false, true);
    delay_ms(10);
    Emm_V5_Pos_Control(4, 0, 1500, 30, motor4_pulse, false, true);
    delay_ms(10);
    
    // 同步触发
    Emm_V5_Synchronous_motion(0);
}
```

---

## 6.8 多机通讯故障排查

| 故障现象 | 可能原因 | 解决方案 |
|---------|---------|---------|
| 某台电机无响应 | 地址设置错误 | 检查电机地址配置 |
| 多台电机同时响应 | 地址冲突 | 确保每台地址唯一 |
| 通信不稳定 | 缺少终端电阻 | 总线两端加120Ω电阻 |
| 通信不稳定 | 线缆过长 | 使用屏蔽双绞线 |
| 同步不准确 | 命令间隔过短 | 增加delay时间到10ms以上 |
| 广播命令无效 | 使用错误地址 | 确认使用地址0 |

---

## 6.9 性能优化建议

### 6.9.1 命令批处理

减少不必要的延时，提高效率：

```c
// 优化前（慢）
Emm_V5_Pos_Control(1, 0, 1000, 20, 3200, false, true);
delay_ms(50);  // 过长
Emm_V5_Pos_Control(2, 0, 1000, 20, 3200, false, true);
delay_ms(50);  // 过长
Emm_V5_Synchronous_motion(0);

// 优化后（快）
Emm_V5_Pos_Control(1, 0, 1000, 20, 3200, false, true);
delay_ms(10);  // 足够
Emm_V5_Pos_Control(2, 0, 1000, 20, 3200, false, true);
delay_ms(10);  // 足够
Emm_V5_Synchronous_motion(0);
```

---

### 6.9.2 错误重试机制

```c
bool send_command_with_retry(uint8_t *cmd, uint8_t len, uint8_t max_retry)
{
    for(uint8_t i = 0; i < max_retry; i++)
    {
        atk_rs485_send_data(cmd, len);
        delay_ms(50);
        
        if(rxFrameFlag && check_response_valid())
        {
            rxFrameFlag = false;
            return true;  // 成功
        }
    }
    return false;  // 失败
}
```

---

[← 上一章：回零功能](05-回零功能.md) | [返回目录](README.md) | [下一章：STM32集成指南 →](07-STM32集成指南.md)
