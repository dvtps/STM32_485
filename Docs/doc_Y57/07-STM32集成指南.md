# 07 - STM32集成指南

[← 上一章：多机通讯](06-多机通讯.md) | [返回目录](README.md)

---

> ⚠️ **V3.0架构更新说明**
> 
> 本文档编写时基于ATK_RS485历史架构。**当前项目已升级到V3.0架构**，主要变化：
> 
> **V3.0新架构**（推荐）:
> ```
> 应用层 → emm_v5.c → emm_uart.c → usart.c → HAL
> ```
> - ✅ 已移除 `ATK_RS485` 目录
> - ✅ 新增统一通信层 `emm_uart.c/h`（220行）
> - ✅ `emm_v5.c` 直接调用 `emm_uart_send()`
> - ✅ 支持阻塞/中断/DMA三种发送模式
> 
> **如何应用V3.0架构**:
> 1. 将文档中的 `atk_rs485_send_data()` 替换为 `emm_uart_send()`
> 2. 不再需要创建 `ATK_RS485` 目录
> 3. 参考 `Drivers/BSP/EMM_V5/emm_uart.c` 实现通信层
> 4. 查看 `.github/copilot-instructions.md` 了解完整架构
> 
> 以下内容保留作为**历史参考和移植原理说明**。

---

## 7.1 集成概述（历史版本参考）

本章详细说明如何将张大头Y系列电机驱动库移植到STM32 HAL库项目中，特别是集成到现有的RS485通信项目。

**目标项目**: STM32F103 + RS485模块
**参考例程**: `Docs/STM32_ZDT_PosMode/`（标准库版本）
**当前实现**: 参考本项目 `Drivers/BSP/EMM_V5/` （V3.0架构）

---

## 7.2 文件结构规划

### 7.2.1 推荐目录结构

```
STM32_485/
├── Drivers/
│   ├── BSP/
│   │   ├── ATK_RS485/          # 现有RS485驱动
│   │   │   ├── atk_rs485.c
│   │   │   └── atk_rs485.h
│   │   ├── EMM_V5/             # ← 新增：电机控制库
│   │   │   ├── emm_v5.c
│   │   │   ├── emm_v5.h
│   │   │   └── emm_v5_config.h
│   │   ├── LED/
│   │   └── KEY/
│   └── SYSTEM/
│       ├── delay/
│       ├── sys/
│       └── usart/
└── Users/
    ├── main.c
    ├── demo.c                  # ← 修改：电机控制演示
    └── ...
```

---

## 7.3 驱动移植步骤

### 步骤1: 创建 emm_v5.h 头文件

```c
/**
 * @file    emm_v5.h
 * @brief   张大头Emm_V5.0步进电机控制库（HAL库适配版本）
 */

#ifndef __EMM_V5_H
#define __EMM_V5_H

#include "./SYSTEM/sys/sys.h"
#include "stdbool.h"
#include "stdint.h"

/* 系统参数枚举 */
typedef enum {
    S_VER   = 0,    /* 版本信息 */
    S_RL    = 1,    /* 转动方向 */
    S_PID   = 2,    /* PID参数 */
    S_VBUS  = 3,    /* 总线电压 */
    S_CPHA  = 5,    /* 相位 */
    S_ENCL  = 7,    /* 编码器值 */
    S_TPOS  = 8,    /* 目标位置 */
    S_VEL   = 9,    /* 实时速度 */
    S_CPOS  = 10,   /* 当前位置 */
    S_PERR  = 11,   /* 位置误差 */
    S_FLAG  = 13,   /* 状态标志位 */
    S_Conf  = 14,   /* 配置参数 */
    S_State = 15,   /* 系统状态 */
    S_ORG   = 16    /* 回零状态 */
} SysParams_t;

/* API函数声明 */
void Emm_V5_Reset_CurPos_To_Zero(uint8_t addr);
void Emm_V5_Reset_Clog_Pro(uint8_t addr);
void Emm_V5_Read_Sys_Params(uint8_t addr, SysParams_t s);
void Emm_V5_Modify_Ctrl_Mode(uint8_t addr, bool svF, uint8_t ctrl_mode);
void Emm_V5_En_Control(uint8_t addr, bool state, bool snF);
void Emm_V5_Vel_Control(uint8_t addr, uint8_t dir, uint16_t vel, uint8_t acc, bool snF);
void Emm_V5_Pos_Control(uint8_t addr, uint8_t dir, uint16_t vel, uint8_t acc, uint32_t clk, bool raF, bool snF);
void Emm_V5_Stop_Now(uint8_t addr, bool snF);
void Emm_V5_Synchronous_motion(uint8_t addr);
void Emm_V5_Origin_Set_O(uint8_t addr, bool svF);
void Emm_V5_Origin_Modify_Params(uint8_t addr, bool svF, uint8_t o_mode, uint8_t o_dir, 
                                  uint16_t o_vel, uint32_t o_tm, uint16_t sl_vel, 
                                  uint16_t sl_ma, uint16_t sl_ms, bool potF);
void Emm_V5_Origin_Trigger_Return(uint8_t addr, uint8_t o_mode, bool snF);
void Emm_V5_Origin_Interrupt(uint8_t addr);

#endif
```

---

### 步骤2: 创建 emm_v5.c 实现文件

```c
/**
 * @file    emm_v5.c
 * @brief   张大头Emm_V5.0步进电机控制库（HAL库适配版本）
 */

#include "emm_v5.h"
#include "./BSP/ATK_RS485/atk_rs485.h"
#include "./SYSTEM/delay/delay.h"

/**
 * @brief   发送命令到电机（内部函数）
 * @param   cmd: 命令缓冲区
 * @param   len: 命令长度
 */
static void emm_v5_send_cmd(uint8_t *cmd, uint8_t len)
{
    atk_rs485_send_data(cmd, len);
}

/**
 * @brief   使能/失能电机
 */
void Emm_V5_En_Control(uint8_t addr, bool state, bool snF)
{
    uint8_t cmd[6];
    cmd[0] = addr;
    cmd[1] = 0xF3;
    cmd[2] = 0xAB;
    cmd[3] = (uint8_t)state;
    cmd[4] = snF;
    cmd[5] = 0x6B;
    
    emm_v5_send_cmd(cmd, 6);
}

/**
 * @brief   位置控制
 */
void Emm_V5_Pos_Control(uint8_t addr, uint8_t dir, uint16_t vel, uint8_t acc, 
                        uint32_t clk, bool raF, bool snF)
{
    uint8_t cmd[13];
    cmd[0]  = addr;
    cmd[1]  = 0xFD;
    cmd[2]  = dir;
    cmd[3]  = (uint8_t)(vel >> 8);
    cmd[4]  = (uint8_t)(vel >> 0);
    cmd[5]  = acc;
    cmd[6]  = (uint8_t)(clk >> 24);
    cmd[7]  = (uint8_t)(clk >> 16);
    cmd[8]  = (uint8_t)(clk >> 8);
    cmd[9]  = (uint8_t)(clk >> 0);
    cmd[10] = raF;
    cmd[11] = snF;
    cmd[12] = 0x6B;
    
    emm_v5_send_cmd(cmd, 13);
}

/**
 * @brief   速度控制
 */
void Emm_V5_Vel_Control(uint8_t addr, uint8_t dir, uint16_t vel, uint8_t acc, bool snF)
{
    uint8_t cmd[8];
    cmd[0] = addr;
    cmd[1] = 0xF6;
    cmd[2] = dir;
    cmd[3] = (uint8_t)(vel >> 8);
    cmd[4] = (uint8_t)(vel >> 0);
    cmd[5] = acc;
    cmd[6] = snF;
    cmd[7] = 0x6B;
    
    emm_v5_send_cmd(cmd, 8);
}

/**
 * @brief   立即停止
 */
void Emm_V5_Stop_Now(uint8_t addr, bool snF)
{
    uint8_t cmd[5];
    cmd[0] = addr;
    cmd[1] = 0xFE;
    cmd[2] = 0x98;
    cmd[3] = snF;
    cmd[4] = 0x6B;
    
    emm_v5_send_cmd(cmd, 5);
}

/**
 * @brief   同步运动触发
 */
void Emm_V5_Synchronous_motion(uint8_t addr)
{
    uint8_t cmd[4];
    cmd[0] = addr;
    cmd[1] = 0xFF;
    cmd[2] = 0x66;
    cmd[3] = 0x6B;
    
    emm_v5_send_cmd(cmd, 4);
}

/**
 * @brief   清零当前位置
 */
void Emm_V5_Reset_CurPos_To_Zero(uint8_t addr)
{
    uint8_t cmd[4];
    cmd[0] = addr;
    cmd[1] = 0x0A;
    cmd[2] = 0x6D;
    cmd[3] = 0x6B;
    
    emm_v5_send_cmd(cmd, 4);
}

/**
 * @brief   解除堵转保护
 */
void Emm_V5_Reset_Clog_Pro(uint8_t addr)
{
    uint8_t cmd[4];
    cmd[0] = addr;
    cmd[1] = 0x0E;
    cmd[2] = 0x52;
    cmd[3] = 0x6B;
    
    emm_v5_send_cmd(cmd, 4);
}

/**
 * @brief   读取系统参数
 */
void Emm_V5_Read_Sys_Params(uint8_t addr, SysParams_t s)
{
    uint8_t i = 0;
    uint8_t cmd[16] = {0};
    
    cmd[i++] = addr;
    
    switch(s) {
        case S_VER:   cmd[i++] = 0x1F; break;
        case S_RL:    cmd[i++] = 0x20; break;
        case S_PID:   cmd[i++] = 0x21; break;
        case S_VBUS:  cmd[i++] = 0x24; break;
        case S_CPHA:  cmd[i++] = 0x27; break;
        case S_ENCL:  cmd[i++] = 0x31; break;
        case S_TPOS:  cmd[i++] = 0x33; break;
        case S_VEL:   cmd[i++] = 0x35; break;
        case S_CPOS:  cmd[i++] = 0x36; break;
        case S_PERR:  cmd[i++] = 0x37; break;
        case S_FLAG:  cmd[i++] = 0x3A; break;
        case S_ORG:   cmd[i++] = 0x3B; break;
        case S_Conf:  cmd[i++] = 0x42; cmd[i++] = 0x6C; break;
        case S_State: cmd[i++] = 0x43; cmd[i++] = 0x7A; break;
        default: break;
    }
    
    cmd[i++] = 0x6B;
    emm_v5_send_cmd(cmd, i);
}

/**
 * @brief   修改控制模式
 */
void Emm_V5_Modify_Ctrl_Mode(uint8_t addr, bool svF, uint8_t ctrl_mode)
{
    uint8_t cmd[6];
    cmd[0] = addr;
    cmd[1] = 0x46;
    cmd[2] = 0x69;
    cmd[3] = svF;
    cmd[4] = ctrl_mode;
    cmd[5] = 0x6B;
    
    emm_v5_send_cmd(cmd, 6);
}

/**
 * @brief   设置单圈回零零点
 */
void Emm_V5_Origin_Set_O(uint8_t addr, bool svF)
{
    uint8_t cmd[5];
    cmd[0] = addr;
    cmd[1] = 0x93;
    cmd[2] = 0x88;
    cmd[3] = svF;
    cmd[4] = 0x6B;
    
    emm_v5_send_cmd(cmd, 5);
}

/**
 * @brief   修改回零参数
 */
void Emm_V5_Origin_Modify_Params(uint8_t addr, bool svF, uint8_t o_mode, uint8_t o_dir, 
                                  uint16_t o_vel, uint32_t o_tm, uint16_t sl_vel, 
                                  uint16_t sl_ma, uint16_t sl_ms, bool potF)
{
    uint8_t cmd[20];
    cmd[0]  = addr;
    cmd[1]  = 0x4C;
    cmd[2]  = 0xAE;
    cmd[3]  = svF;
    cmd[4]  = o_mode;
    cmd[5]  = o_dir;
    cmd[6]  = (uint8_t)(o_vel >> 8);
    cmd[7]  = (uint8_t)(o_vel >> 0);
    cmd[8]  = (uint8_t)(o_tm >> 24);
    cmd[9]  = (uint8_t)(o_tm >> 16);
    cmd[10] = (uint8_t)(o_tm >> 8);
    cmd[11] = (uint8_t)(o_tm >> 0);
    cmd[12] = (uint8_t)(sl_vel >> 8);
    cmd[13] = (uint8_t)(sl_vel >> 0);
    cmd[14] = (uint8_t)(sl_ma >> 8);
    cmd[15] = (uint8_t)(sl_ma >> 0);
    cmd[16] = (uint8_t)(sl_ms >> 8);
    cmd[17] = (uint8_t)(sl_ms >> 0);
    cmd[18] = potF;
    cmd[19] = 0x6B;
    
    emm_v5_send_cmd(cmd, 20);
}

/**
 * @brief   触发回零
 */
void Emm_V5_Origin_Trigger_Return(uint8_t addr, uint8_t o_mode, bool snF)
{
    uint8_t cmd[5];
    cmd[0] = addr;
    cmd[1] = 0x9A;
    cmd[2] = o_mode;
    cmd[3] = snF;
    cmd[4] = 0x6B;
    
    emm_v5_send_cmd(cmd, 5);
}

/**
 * @brief   强制中断回零
 */
void Emm_V5_Origin_Interrupt(uint8_t addr)
{
    uint8_t cmd[4];
    cmd[0] = addr;
    cmd[1] = 0x9C;
    cmd[2] = 0x48;
    cmd[3] = 0x6B;
    
    emm_v5_send_cmd(cmd, 4);
}
```

---

## 7.4 现有RS485驱动适配

### 7.4.1 检查 atk_rs485.c 波特率

确保RS485波特率设置为115200（电机通信标准）：

```c
// main.c 中
atk_rs485_init(115200);  // ← 改为115200（之前可能是256000）
```

---

### 7.4.2 添加IDLE中断支持（可选优化）

**为什么需要IDLE中断？**
- 当前项目使用RXNE中断逐字节接收
- IDLE中断可检测一帧数据接收完成
- 提高响应帧解析的准确性

**修改 atk_rs485.c**:

```c
// 在 atk_rs485_init() 中添加
void atk_rs485_init(uint32_t baudrate)
{
    // ... 现有初始化代码 ...
    
    // 使能IDLE中断（可选）
    __HAL_UART_ENABLE_IT(&g_rs458_handler, UART_IT_IDLE);
}

// 在 stm32f1xx_it.c 的 USART2_IRQHandler 中添加
void USART2_IRQHandler(void)
{
    // 现有RXNE中断处理
    if(__HAL_UART_GET_FLAG(&g_rs458_handler, UART_FLAG_RXNE))
    {
        // ... 现有代码 ...
    }
    
    // 新增IDLE中断处理
    if(__HAL_UART_GET_FLAG(&g_rs458_handler, UART_FLAG_IDLE))
    {
        __HAL_UART_CLEAR_IDLEFLAG(&g_rs458_handler);
        
        // 标记一帧接收完成
        g_RS485_frame_complete = 1;
    }
}
```

---

## 7.5 应用层集成

### 7.5.1 修改 demo.c

```c
/**
 * @file    demo.c
 * @brief   电机控制演示程序
 */

#include "demo.h"
#include "./BSP/ATK_RS485/atk_rs485.h"
#include "./BSP/EMM_V5/emm_v5.h"
#include "./SYSTEM/usart/usart.h"
#include "./SYSTEM/delay/delay.h"
#include "./BSP/KEY/key.h"
#include "./BSP/LED/led.h"
#include <stdio.h>

/**
 * @brief   示例1：基本位置控制
 */
void demo_basic_position_control(void)
{
    printf("\n=== 基本位置控制演示 ===\n");
    
    // 使能电机
    Emm_V5_En_Control(1, true, false);
    delay_ms(100);
    printf("电机已使能\n");
    
    // 转动1圈（3200脉冲）
    printf("顺时针转动1圈...\n");
    Emm_V5_Pos_Control(1, 0, 1000, 20, 3200, false, false);
    delay_ms(5000);
    
    // 反向转动1圈
    printf("逆时针转动1圈...\n");
    Emm_V5_Pos_Control(1, 1, 1000, 20, 3200, false, false);
    delay_ms(5000);
    
    // 失能电机
    Emm_V5_En_Control(1, false, false);
    printf("电机已失能\n");
}

/**
 * @brief   示例2：速度控制
 */
void demo_velocity_control(void)
{
    printf("\n=== 速度控制演示 ===\n");
    
    Emm_V5_En_Control(1, true, false);
    delay_ms(100);
    
    // 启动：500RPM
    printf("启动：500RPM\n");
    Emm_V5_Vel_Control(1, 0, 500, 20, false);
    delay_ms(3000);
    
    // 加速到1500RPM
    printf("加速到：1500RPM\n");
    Emm_V5_Vel_Control(1, 0, 1500, 20, false);
    delay_ms(3000);
    
    // 停止
    printf("停止\n");
    Emm_V5_Stop_Now(1, false);
    delay_ms(1000);
    
    Emm_V5_En_Control(1, false, false);
}

/**
 * @brief   示例3：按键交互控制
 */
void demo_interactive_control(void)
{
    uint8_t key;
    uint8_t motor_enabled = 0;
    
    printf("\n=== 按键交互控制 ===\n");
    printf("KEY0: 使能/失能电机\n");
    printf("WKUP: 转动1圈\n");
    
    while(1)
    {
        key = key_scan(0);
        
        if(key == KEY0_PRES)
        {
            motor_enabled = !motor_enabled;
            Emm_V5_En_Control(1, motor_enabled, false);
            printf("电机 %s\n", motor_enabled ? "使能" : "失能");
            delay_ms(100);
        }
        else if(key == WKUP_PRES)
        {
            if(motor_enabled)
            {
                printf("转动1圈\n");
                Emm_V5_Pos_Control(1, 0, 1000, 20, 3200, false, false);
            }
            else
            {
                printf("请先使能电机！\n");
            }
            delay_ms(100);
        }
        
        // LED闪烁提示运行
        LED0_TOGGLE();
        delay_ms(500);
    }
}

/**
 * @brief   主演示入口函数
 */
void demo_run(void)
{
    // 初始化RS485（波特率115200）
    atk_rs485_init(115200);
    printf("RS485初始化完成，波特率115200\n");
    
    // 等待电机上电初始化
    printf("等待电机初始化...\n");
    delay_ms(2000);
    printf("电机初始化完成\n");
    
    // 选择运行的演示
    // demo_basic_position_control();
    // demo_velocity_control();
    demo_interactive_control();
}
```

---

### 7.5.2 修改 main.c

```c
/**
 * @file    main.c
 */

#include "./SYSTEM/sys/sys.h"
#include "./SYSTEM/usart/usart.h"
#include "./SYSTEM/delay/delay.h"
#include "./BSP/LED/led.h"
#include "./BSP/KEY/key.h"
#include "demo.h"

void show_mesg(void)
{
    printf("\n");
    printf("********************************\r\n");
    printf("ZDT Y-Series Motor Control\r\n");
    printf("Emm_V5.0 Driver\r\n");
    printf("ATOM@ALIENTEK + ZhangDaTou\r\n");
    printf("********************************\r\n");
    printf("\r\n");
}

int main(void)
{
    HAL_Init();                             /* 初始化HAL库 */
    sys_stm32_clock_init(RCC_PLL_MUL9);     /* 72MHz */
    delay_init(72);                         /* 延时初始化 */
    usart_init(115200);                     /* 串口1调试 */
    led_init();                             /* LED初始化 */
    key_init();                             /* 按键初始化 */
    show_mesg();                            /* 显示信息 */
    demo_run();                             /* 运行演示 */
}
```

---

## 7.6 Keil工程配置

### 7.6.1 添加源文件到工程

在Keil MDK中：

1. 右键 `BSP` 组 → `Add Existing Files to Group`
2. 添加 `emm_v5.c`
3. 在 `Options for Target` → `C/C++` → `Include Paths` 中添加：
   ```
   ..\..\..\Drivers\BSP\EMM_V5
   ```

---

### 7.6.2 编译并下载

```
Build → Rebuild All Target Files
```

确认编译通过，无错误和警告。

---

## 7.7 完整测试流程

### 7.7.1 硬件连接检查清单

- [ ] 电机电源：12V~48V DC，极性正确
- [ ] RS485连接：A-A、B-B、GND-GND
- [ ] 终端电阻：总线两端各120Ω（如有多机）
- [ ] 电机地址：确认为1号（或已设置的地址）
- [ ] STM32供电：USB或外部5V
- [ ] 串口调试：USART1连接到PC（查看打印信息）

---

### 7.7.2 软件测试步骤

1. **编译下载**
   ```
   Keil → Build → Download to Flash
   ```

2. **打开串口工具**
   - 波特率：115200
   - 数据位：8, 停止位：1, 无校验

3. **观察启动信息**
   ```
   ZDT Y-Series Motor Control
   Emm_V5.0 Driver
   RS485初始化完成，波特率115200
   等待电机初始化...
   电机初始化完成
   ```

4. **按键测试**
   - 按KEY0：使能电机（应听到电机锁定声音）
   - 按WKUP：电机转动1圈
   - 再按KEY0：失能电机

5. **观察LED**
   - LED0应持续闪烁，表示程序运行正常

---

## 7.8 常见问题排查

### 问题1: 编译错误 - 找不到头文件

**错误信息**: `cannot open source input file "emm_v5.h"`

**解决**:
- 检查文件是否添加到工程
- 检查Include Paths路径是否正确

---

### 问题2: 电机无响应

**排查步骤**:
1. 检查电机电源是否供电
2. 用示波器/逻辑分析仪观察RS485 A/B线是否有波形
3. 确认波特率设置为115200
4. 检查电机地址是否为1
5. 尝试交换A和B线

---

### 问题3: 串口无打印输出

**排查步骤**:
1. 检查USART1连接是否正确（TX→RX，RX→TX）
2. 确认串口工具波特率115200
3. 在main.c中添加测试代码：
   ```c
   printf("Test\r\n");
   ```

---

## 7.9 性能优化建议

### 7.9.1 使用DMA传输（可选）

将RS485发送改为DMA模式，释放CPU：

```c
void atk_rs485_send_data_dma(uint8_t *buf, uint8_t len)
{
    HAL_UART_Transmit_DMA(&g_rs458_handler, buf, len);
}
```

---

### 7.9.2 接收缓冲区优化

增加接收缓冲区大小，防止数据丢失：

```c
// atk_rs485.h
#define RS485_REC_LEN   256  // 原来220，改为256
```

---

## 7.10 后续扩展方向

- [ ] 添加响应帧解析函数
- [ ] 实现命令超时重试机制
- [ ] 添加多机地址管理
- [ ] 集成回零功能到初始化流程
- [ ] 添加电机状态实时监控
- [ ] 实现运动轨迹规划算法

---

[← 上一章：多机通讯](06-多机通讯.md) | [返回目录](README.md)
