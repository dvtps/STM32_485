# 内存池设计方案（对象池模式）

## 问题分析

当前STM32_485项目存在以下内存管理风险：
- FIFO缓冲区（256字节）频繁操作
- Modbus/EMM_V5协议帧缓冲区临时分配
- 多电机管理可能导致栈溢出（每个电机状态约50字节）

## 设计方案

### 静态内存池架构

```c
/* Drivers/Middlewares/MEMORY_POOL/mem_pool.h */
#ifndef __MEM_POOL_H
#define __MEM_POOL_H

#include <stdint.h>
#include <stdbool.h>

/* 内存池配置 */
#define MEM_POOL_FRAME_SIZE     256     /* 协议帧最大长度 */
#define MEM_POOL_FRAME_COUNT    4       /* 同时支持4个帧缓冲 */
#define MEM_POOL_MOTOR_STATE_SIZE 64    /* 电机状态结构体大小 */
#define MEM_POOL_MOTOR_COUNT    8       /* 最多8个电机 */

/* 内存块状态 */
typedef enum {
    MEM_BLOCK_FREE = 0,
    MEM_BLOCK_ALLOCATED = 1
} mem_block_state_t;

/* 帧缓冲池 */
typedef struct {
    uint8_t buffer[MEM_POOL_FRAME_SIZE];
    mem_block_state_t state;
    uint32_t alloc_time;    /* 分配时间（用于检测泄漏）*/
} frame_buffer_t;

/* 电机状态池 */
typedef struct {
    uint8_t state_data[MEM_POOL_MOTOR_STATE_SIZE];
    mem_block_state_t state;
    uint8_t motor_id;
} motor_state_buffer_t;

/* 内存池统计 */
typedef struct {
    uint32_t frame_alloc_count;     /* 帧缓冲分配次数 */
    uint32_t frame_free_count;      /* 帧缓冲释放次数 */
    uint32_t frame_leak_count;      /* 检测到的泄漏次数 */
    uint32_t motor_alloc_count;     /* 电机状态分配次数 */
    uint32_t motor_free_count;      /* 电机状态释放次数 */
    uint8_t frame_peak_usage;       /* 峰值帧缓冲使用数 */
    uint8_t motor_peak_usage;       /* 峰值电机状态使用数 */
} mem_pool_stats_t;

/* API函数 */
void mem_pool_init(void);
uint8_t* mem_pool_alloc_frame(void);
void mem_pool_free_frame(uint8_t *ptr);
uint8_t* mem_pool_alloc_motor_state(uint8_t motor_id);
void mem_pool_free_motor_state(uint8_t motor_id);
const mem_pool_stats_t* mem_pool_get_stats(void);
void mem_pool_check_leaks(void);  /* 定期调用，检测超时未释放的内存 */

#endif
```

### 实现要点

```c
/* Drivers/Middlewares/MEMORY_POOL/mem_pool.c */

/* 静态内存池（不使用malloc/free） */
static frame_buffer_t g_frame_pool[MEM_POOL_FRAME_COUNT];
static motor_state_buffer_t g_motor_pool[MEM_POOL_MOTOR_COUNT];
static mem_pool_stats_t g_pool_stats;

/* 内存泄漏检测阈值（5秒未释放视为泄漏） */
#define MEM_LEAK_TIMEOUT_MS  5000

void mem_pool_init(void)
{
    memset(g_frame_pool, 0, sizeof(g_frame_pool));
    memset(g_motor_pool, 0, sizeof(g_motor_pool));
    memset(&g_pool_stats, 0, sizeof(g_pool_stats));
}

uint8_t* mem_pool_alloc_frame(void)
{
    __disable_irq();  /* 临界区保护 */
    
    for (uint8_t i = 0; i < MEM_POOL_FRAME_COUNT; i++) {
        if (g_frame_pool[i].state == MEM_BLOCK_FREE) {
            g_frame_pool[i].state = MEM_BLOCK_ALLOCATED;
            g_frame_pool[i].alloc_time = HAL_GetTick();
            g_pool_stats.frame_alloc_count++;
            
            /* 更新峰值统计 */
            uint8_t current_usage = 0;
            for (uint8_t j = 0; j < MEM_POOL_FRAME_COUNT; j++) {
                if (g_frame_pool[j].state == MEM_BLOCK_ALLOCATED) {
                    current_usage++;
                }
            }
            if (current_usage > g_pool_stats.frame_peak_usage) {
                g_pool_stats.frame_peak_usage = current_usage;
            }
            
            __enable_irq();
            return g_frame_pool[i].buffer;
        }
    }
    
    __enable_irq();
    return NULL;  /* 池已满 */
}

void mem_pool_free_frame(uint8_t *ptr)
{
    if (ptr == NULL) return;
    
    __disable_irq();
    
    for (uint8_t i = 0; i < MEM_POOL_FRAME_COUNT; i++) {
        if (g_frame_pool[i].buffer == ptr) {
            g_frame_pool[i].state = MEM_BLOCK_FREE;
            g_pool_stats.frame_free_count++;
            __enable_irq();
            return;
        }
    }
    
    __enable_irq();
    /* 未找到该指针，可能是非法释放 */
}

void mem_pool_check_leaks(void)
{
    uint32_t now = HAL_GetTick();
    
    for (uint8_t i = 0; i < MEM_POOL_FRAME_COUNT; i++) {
        if (g_frame_pool[i].state == MEM_BLOCK_ALLOCATED) {
            if (now - g_frame_pool[i].alloc_time > MEM_LEAK_TIMEOUT_MS) {
                /* 检测到泄漏，强制释放并记录 */
                g_frame_pool[i].state = MEM_BLOCK_FREE;
                g_pool_stats.frame_leak_count++;
                
                printf("[MEM] Leak detected: Frame %d held for %lums\r\n",
                       i, now - g_frame_pool[i].alloc_time);
            }
        }
    }
}
```

### 使用示例

```c
/* Core/App/main.c 主循环中 */
if (g_usart2_frame_ready) {
    g_usart2_frame_ready = 0;
    
    /* 从内存池获取缓冲区（而非栈分配） */
    uint8_t *frame_buf = mem_pool_alloc_frame();
    if (frame_buf == NULL) {
        printf("[ERROR] Frame pool exhausted!\r\n");
        continue;
    }
    
    /* 从FIFO出队数据 */
    uint16_t frame_len = /* ... */;
    
    /* 处理协议帧 */
    protocol_router_process(frame_buf, frame_len);
    
    /* 释放缓冲区 */
    mem_pool_free_frame(frame_buf);
}

/* 定期检测内存泄漏（每秒调用一次） */
static uint32_t last_leak_check = 0;
if (HAL_GetTick() - last_leak_check > 1000) {
    mem_pool_check_leaks();
    last_leak_check = HAL_GetTick();
}
```

## 资源占用评估

```
Flash: +800 bytes (实现代码)
RAM:   +1.5KB (4×256字节帧缓冲 + 8×64字节电机状态 + 统计变量)
```

## 优势

1. **消除内存碎片**：静态分配，无malloc/free开销
2. **确定性延迟**：分配时间O(n)，n=池大小（可预测）
3. **泄漏检测**：自动检测超时未释放的内存
4. **统计可见**：峰值使用率监控，便于容量规划

## USMART调试命令

```c
void mem_stats(void)
{
    const mem_pool_stats_t *stats = mem_pool_get_stats();
    
    printf("Frame Pool: Alloc=%lu Free=%lu Leak=%lu Peak=%u/%u\r\n",
           stats->frame_alloc_count, stats->frame_free_count,
           stats->frame_leak_count, stats->frame_peak_usage, 
           MEM_POOL_FRAME_COUNT);
    
    printf("Motor Pool: Alloc=%lu Free=%lu Peak=%u/%u\r\n",
           stats->motor_alloc_count, stats->motor_free_count,
           stats->motor_peak_usage, MEM_POOL_MOTOR_COUNT);
}
```
