# 状态机模式 - 电机控制流程管理

## 问题分析

当前`motor_zdt.c`使用简单的按键触发模式，缺乏：
- 复杂运动序列管理（如：回零→移动→停止→检测到位）
- 错误状态处理和恢复机制
- 超时检测和自动重试

## 设计方案

### 有限状态机（FSM）架构

```c
/* Drivers/BSP/MOTOR_FSM/motor_fsm.h */
#ifndef __MOTOR_FSM_H
#define __MOTOR_FSM_H

#include <stdint.h>
#include <stdbool.h>

/* 电机状态定义 */
typedef enum {
    MOTOR_STATE_IDLE = 0,           /* 空闲 */
    MOTOR_STATE_ENABLING,           /* 正在使能 */
    MOTOR_STATE_ENABLED,            /* 已使能 */
    MOTOR_STATE_HOMING,             /* 回零中 */
    MOTOR_STATE_MOVING,             /* 运动中 */
    MOTOR_STATE_STOPPING,           /* 停止中 */
    MOTOR_STATE_POSITION_REACHED,   /* 到位 */
    MOTOR_STATE_ERROR,              /* 错误状态 */
    MOTOR_STATE_TIMEOUT,            /* 超时 */
} motor_state_t;

/* 电机事件定义 */
typedef enum {
    MOTOR_EVENT_ENABLE_CMD = 0,     /* 使能命令 */
    MOTOR_EVENT_DISABLE_CMD,        /* 失能命令 */
    MOTOR_EVENT_HOME_CMD,           /* 回零命令 */
    MOTOR_EVENT_MOVE_CMD,           /* 移动命令 */
    MOTOR_EVENT_STOP_CMD,           /* 停止命令 */
    MOTOR_EVENT_ACK_RECEIVED,       /* 收到响应 */
    MOTOR_EVENT_POSITION_REACHED,   /* 到位信号 */
    MOTOR_EVENT_ERROR_OCCURRED,     /* 错误发生 */
    MOTOR_EVENT_TIMEOUT,            /* 超时 */
} motor_event_t;

/* 状态机上下文 */
typedef struct {
    uint8_t motor_addr;             /* 电机地址 */
    motor_state_t current_state;    /* 当前状态 */
    motor_state_t previous_state;   /* 前一状态（用于错误恢复）*/
    
    /* 运动参数 */
    uint8_t target_dir;
    uint16_t target_speed;
    uint32_t target_pulses;
    
    /* 超时检测 */
    uint32_t state_enter_time;      /* 进入当前状态的时间 */
    uint32_t timeout_ms;            /* 超时阈值 */
    
    /* 错误处理 */
    uint8_t error_code;
    uint8_t retry_count;            /* 重试次数 */
    uint8_t max_retry;              /* 最大重试次数 */
    
    /* 回调函数 */
    void (*on_state_changed)(uint8_t addr, motor_state_t old_state, motor_state_t new_state);
    void (*on_error)(uint8_t addr, uint8_t error_code);
} motor_fsm_context_t;

/* API函数 */
void motor_fsm_init(motor_fsm_context_t *ctx, uint8_t motor_addr);
void motor_fsm_dispatch_event(motor_fsm_context_t *ctx, motor_event_t event);
void motor_fsm_update(motor_fsm_context_t *ctx);  /* 主循环中定期调用 */
motor_state_t motor_fsm_get_state(const motor_fsm_context_t *ctx);
bool motor_fsm_is_busy(const motor_fsm_context_t *ctx);

/* 高级API（封装状态机） */
int motor_fsm_enable_and_home(motor_fsm_context_t *ctx);
int motor_fsm_move_to_position(motor_fsm_context_t *ctx, uint8_t dir, 
                                uint16_t speed, uint32_t pulses);
int motor_fsm_emergency_stop(motor_fsm_context_t *ctx);

#endif
```

### 状态转换表实现

```c
/* Drivers/BSP/MOTOR_FSM/motor_fsm.c */

/* 状态转换表 */
typedef motor_state_t (*state_handler_t)(motor_fsm_context_t *ctx, motor_event_t event);

static motor_state_t handle_idle_state(motor_fsm_context_t *ctx, motor_event_t event);
static motor_state_t handle_enabling_state(motor_fsm_context_t *ctx, motor_event_t event);
static motor_state_t handle_enabled_state(motor_fsm_context_t *ctx, motor_event_t event);
static motor_state_t handle_homing_state(motor_fsm_context_t *ctx, motor_event_t event);
static motor_state_t handle_moving_state(motor_fsm_context_t *ctx, motor_event_t event);
static motor_state_t handle_error_state(motor_fsm_context_t *ctx, motor_event_t event);

static const state_handler_t g_state_table[] = {
    [MOTOR_STATE_IDLE]              = handle_idle_state,
    [MOTOR_STATE_ENABLING]          = handle_enabling_state,
    [MOTOR_STATE_ENABLED]           = handle_enabled_state,
    [MOTOR_STATE_HOMING]            = handle_homing_state,
    [MOTOR_STATE_MOVING]            = handle_moving_state,
    [MOTOR_STATE_ERROR]             = handle_error_state,
    /* ... 其他状态 ... */
};

void motor_fsm_init(motor_fsm_context_t *ctx, uint8_t motor_addr)
{
    memset(ctx, 0, sizeof(motor_fsm_context_t));
    ctx->motor_addr = motor_addr;
    ctx->current_state = MOTOR_STATE_IDLE;
    ctx->timeout_ms = 5000;  /* 默认5秒超时 */
    ctx->max_retry = 3;      /* 最多重试3次 */
}

void motor_fsm_dispatch_event(motor_fsm_context_t *ctx, motor_event_t event)
{
    motor_state_t new_state;
    
    /* 调用当前状态的处理函数 */
    if (ctx->current_state < sizeof(g_state_table) / sizeof(state_handler_t)) {
        new_state = g_state_table[ctx->current_state](ctx, event);
        
        if (new_state != ctx->current_state) {
            /* 状态变化，触发回调 */
            if (ctx->on_state_changed) {
                ctx->on_state_changed(ctx->motor_addr, ctx->current_state, new_state);
            }
            
            ctx->previous_state = ctx->current_state;
            ctx->current_state = new_state;
            ctx->state_enter_time = HAL_GetTick();
            
            printf("[FSM] Motor#%d: %d -> %d (Event=%d)\r\n",
                   ctx->motor_addr, ctx->previous_state, new_state, event);
        }
    }
}

void motor_fsm_update(motor_fsm_context_t *ctx)
{
    uint32_t now = HAL_GetTick();
    
    /* 超时检测 */
    if (ctx->timeout_ms > 0 && 
        now - ctx->state_enter_time > ctx->timeout_ms) {
        motor_fsm_dispatch_event(ctx, MOTOR_EVENT_TIMEOUT);
    }
}

/* 示例：IDLE状态处理 */
static motor_state_t handle_idle_state(motor_fsm_context_t *ctx, motor_event_t event)
{
    switch (event) {
        case MOTOR_EVENT_ENABLE_CMD:
            /* 发送使能命令 */
            Emm_V5_En_Control(ctx->motor_addr, true, false);
            return MOTOR_STATE_ENABLING;
            
        case MOTOR_EVENT_HOME_CMD:
            /* 需要先使能 */
            Emm_V5_En_Control(ctx->motor_addr, true, false);
            return MOTOR_STATE_ENABLING;  /* 使能完成后再回零 */
            
        default:
            return MOTOR_STATE_IDLE;  /* 保持当前状态 */
    }
}

/* 示例：MOVING状态处理 */
static motor_state_t handle_moving_state(motor_fsm_context_t *ctx, motor_event_t event)
{
    switch (event) {
        case MOTOR_EVENT_POSITION_REACHED:
            return MOTOR_STATE_POSITION_REACHED;
            
        case MOTOR_EVENT_STOP_CMD:
            Emm_V5_Stop_Now(ctx->motor_addr, false);
            return MOTOR_STATE_STOPPING;
            
        case MOTOR_EVENT_ERROR_OCCURRED:
            ctx->error_code = /* 从响应帧解析错误码 */;
            return MOTOR_STATE_ERROR;
            
        case MOTOR_EVENT_TIMEOUT:
            /* 运动超时，进入错误状态 */
            ctx->error_code = 0xFF;  /* 超时错误码 */
            return MOTOR_STATE_ERROR;
            
        default:
            return MOTOR_STATE_MOVING;
    }
}

/* 示例：ERROR状态处理（自动重试）*/
static motor_state_t handle_error_state(motor_fsm_context_t *ctx, motor_event_t event)
{
    if (ctx->retry_count < ctx->max_retry) {
        ctx->retry_count++;
        printf("[FSM] Motor#%d retry %d/%d\r\n",
               ctx->motor_addr, ctx->retry_count, ctx->max_retry);
        
        /* 返回前一状态重试 */
        return ctx->previous_state;
    } else {
        /* 重试次数耗尽，触发错误回调 */
        if (ctx->on_error) {
            ctx->on_error(ctx->motor_addr, ctx->error_code);
        }
        return MOTOR_STATE_ERROR;  /* 保持错误状态 */
    }
}
```

### 高级封装API

```c
/* 组合动作：使能并回零 */
int motor_fsm_enable_and_home(motor_fsm_context_t *ctx)
{
    if (ctx->current_state != MOTOR_STATE_IDLE) {
        return -1;  /* 电机忙碌 */
    }
    
    /* 设置回调：使能完成后自动触发回零 */
    ctx->on_state_changed = [](uint8_t addr, motor_state_t old, motor_state_t new) {
        if (new == MOTOR_STATE_ENABLED) {
            motor_fsm_dispatch_event(ctx, MOTOR_EVENT_HOME_CMD);
        }
    };
    
    motor_fsm_dispatch_event(ctx, MOTOR_EVENT_ENABLE_CMD);
    return 0;
}

/* 运动到指定位置（带超时保护） */
int motor_fsm_move_to_position(motor_fsm_context_t *ctx, uint8_t dir,
                                uint16_t speed, uint32_t pulses)
{
    if (!motor_fsm_is_busy(ctx) && ctx->current_state == MOTOR_STATE_ENABLED) {
        ctx->target_dir = dir;
        ctx->target_speed = speed;
        ctx->target_pulses = pulses;
        
        /* 根据脉冲数计算超时时间（加20%余量） */
        ctx->timeout_ms = (pulses * 60000 / speed / 3200) * 1.2;
        
        Emm_V5_Pos_Control(ctx->motor_addr, dir, speed, 10, pulses, false, false);
        motor_fsm_dispatch_event(ctx, MOTOR_EVENT_MOVE_CMD);
        return 0;
    }
    return -1;
}
```

### 在主循环中使用

```c
/* Core/App/main.c */
static motor_fsm_context_t g_motor1_fsm;
static motor_fsm_context_t g_motor2_fsm;

void motor_init(void)
{
    motor_fsm_init(&g_motor1_fsm, 0x01);
    motor_fsm_init(&g_motor2_fsm, 0x02);
    
    /* 设置错误回调 */
    g_motor1_fsm.on_error = [](uint8_t addr, uint8_t err) {
        printf("[ERROR] Motor#%d error code: 0x%02X\r\n", addr, err);
        led0_toggle();  /* LED闪烁提示错误 */
    };
}

int main(void)
{
    /* ... 初始化代码 ... */
    motor_init();
    
    while (1) {
        /* 定期更新状态机（检测超时）*/
        motor_fsm_update(&g_motor1_fsm);
        motor_fsm_update(&g_motor2_fsm);
        
        /* 处理电机响应帧，触发事件 */
        if (g_emm_frame_complete) {
            g_emm_frame_complete = 0;
            
            if (g_emm_rx_cmd[2] == 0xE6) {  /* 位置到达 */
                motor_fsm_dispatch_event(&g_motor1_fsm, MOTOR_EVENT_POSITION_REACHED);
            }
        }
        
        /* 按键触发复杂动作 */
        if (key == KEY0_PRES) {
            motor_fsm_enable_and_home(&g_motor1_fsm);  /* 使能并回零 */
        }
        
        if (key == WKUP_PRES) {
            /* 移动到指定位置（自动超时保护）*/
            motor_fsm_move_to_position(&g_motor1_fsm, 0, 300, 3200);
        }
        
        delay_ms(10);
    }
}
```

## 优势

1. **清晰的状态管理**：每个状态职责明确，易于理解和维护
2. **自动超时检测**：防止电机卡死导致系统挂起
3. **错误自动重试**：提高系统鲁棒性
4. **复杂序列编排**：支持多步骤运动流程（使能→回零→移动→检测）
5. **代码复用**：多个电机共用同一状态机逻辑

## 资源占用

```
Flash: +1.5KB (状态机实现 + 转换表)
RAM:   ~80 bytes/电机 (状态机上下文)
```

## 测试建议

1. 模拟超时场景（拔掉电机电源）
2. 验证自动重试机制
3. 测试错误状态到正常状态的恢复
4. 压力测试：快速切换命令
