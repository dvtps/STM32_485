# 观察者模式 - 事件驱动架构

## 问题分析

当前架构缺点：
- 主循环中多处`if (g_xxx_flag)`轮询检测，代码耦合度高
- 协议路由、电机响应、FIFO溢出等事件分散处理
- 新增功能需要修改多个文件（违反开闭原则）

## 设计方案

### 事件总线（Event Bus）架构

```c
/* Drivers/Middlewares/EVENT_BUS/event_bus.h */
#ifndef __EVENT_BUS_H
#define __EVENT_BUS_H

#include <stdint.h>
#include <stdbool.h>

/* 事件类型定义 */
typedef enum {
    EVENT_NONE = 0,
    
    /* 通信事件 */
    EVENT_USART2_FRAME_READY,       /* USART2帧就绪 */
    EVENT_USART2_IDLE,              /* USART2空闲中断 */
    EVENT_FIFO_OVERFLOW,            /* FIFO溢出 */
    EVENT_CRC_ERROR,                /* CRC校验错误 */
    
    /* 协议事件 */
    EVENT_MODBUS_FRAME_RECEIVED,    /* Modbus帧接收 */
    EVENT_EMM_V5_FRAME_RECEIVED,    /* EMM_V5帧接收 */
    EVENT_UNKNOWN_PROTOCOL,         /* 未知协议 */
    
    /* 电机事件 */
    EVENT_MOTOR_POSITION_REACHED,   /* 电机到位 */
    EVENT_MOTOR_ERROR,              /* 电机错误 */
    EVENT_MOTOR_STALL,              /* 电机堵转 */
    
    /* 系统事件 */
    EVENT_WATCHDOG_TIMEOUT,         /* 看门狗超时 */
    EVENT_MEMORY_LEAK,              /* 内存泄漏检测 */
    EVENT_BUTTON_PRESSED,           /* 按键按下 */
    
    EVENT_TYPE_MAX
} event_type_t;

/* 事件数据结构 */
typedef struct {
    event_type_t type;
    uint32_t timestamp;     /* 事件发生时间 */
    uint8_t priority;       /* 优先级 0=最高 */
    
    /* 事件携带的数据（联合体节省内存）*/
    union {
        struct {
            uint8_t *data;
            uint16_t length;
        } frame_data;       /* 帧数据 */
        
        struct {
            uint8_t motor_id;
            uint8_t error_code;
        } motor_data;       /* 电机数据 */
        
        struct {
            uint8_t key_code;
        } button_data;      /* 按键数据 */
        
        uint32_t raw_data;  /* 通用数据 */
    } data;
} event_t;

/* 事件回调函数类型 */
typedef void (*event_callback_t)(const event_t *event, void *user_data);

/* 订阅者信息 */
typedef struct {
    event_type_t event_type;
    event_callback_t callback;
    void *user_data;
    bool enabled;
} subscriber_t;

/* 事件总线配置 */
#define EVENT_BUS_MAX_SUBSCRIBERS   16  /* 最多16个订阅者 */
#define EVENT_QUEUE_SIZE            8   /* 事件队列深度 */

/* API函数 */
void event_bus_init(void);
int event_bus_subscribe(event_type_t type, event_callback_t callback, void *user_data);
int event_bus_unsubscribe(event_type_t type, event_callback_t callback);
int event_bus_publish(const event_t *event);
void event_bus_dispatch(void);  /* 主循环中调用，分发事件 */
void event_bus_clear_queue(void);

/* 快捷发布函数 */
int event_publish_frame_ready(uint8_t *data, uint16_t length);
int event_publish_motor_error(uint8_t motor_id, uint8_t error_code);
int event_publish_button_pressed(uint8_t key_code);

#endif
```

### 实现核心

```c
/* Drivers/Middlewares/EVENT_BUS/event_bus.c */

/* 订阅者列表 */
static subscriber_t g_subscribers[EVENT_BUS_MAX_SUBSCRIBERS];
static uint8_t g_subscriber_count = 0;

/* 环形事件队列 */
static event_t g_event_queue[EVENT_QUEUE_SIZE];
static uint8_t g_queue_head = 0;
static uint8_t g_queue_tail = 0;
static uint8_t g_queue_count = 0;

/* 统计信息 */
static uint32_t g_total_published = 0;
static uint32_t g_total_dispatched = 0;
static uint32_t g_queue_overflow = 0;

void event_bus_init(void)
{
    memset(g_subscribers, 0, sizeof(g_subscribers));
    memset(g_event_queue, 0, sizeof(g_event_queue));
    g_subscriber_count = 0;
    g_queue_head = 0;
    g_queue_tail = 0;
    g_queue_count = 0;
}

int event_bus_subscribe(event_type_t type, event_callback_t callback, void *user_data)
{
    if (g_subscriber_count >= EVENT_BUS_MAX_SUBSCRIBERS) {
        return -1;  /* 订阅者已满 */
    }
    
    g_subscribers[g_subscriber_count].event_type = type;
    g_subscribers[g_subscriber_count].callback = callback;
    g_subscribers[g_subscriber_count].user_data = user_data;
    g_subscribers[g_subscriber_count].enabled = true;
    g_subscriber_count++;
    
    return 0;
}

int event_bus_publish(const event_t *event)
{
    __disable_irq();
    
    if (g_queue_count >= EVENT_QUEUE_SIZE) {
        /* 队列满，丢弃事件（也可选择覆盖最旧事件）*/
        g_queue_overflow++;
        __enable_irq();
        return -1;
    }
    
    /* 入队 */
    g_event_queue[g_queue_tail] = *event;
    g_event_queue[g_queue_tail].timestamp = HAL_GetTick();
    g_queue_tail = (g_queue_tail + 1) % EVENT_QUEUE_SIZE;
    g_queue_count++;
    g_total_published++;
    
    __enable_irq();
    return 0;
}

void event_bus_dispatch(void)
{
    while (g_queue_count > 0) {
        __disable_irq();
        
        /* 出队 */
        event_t event = g_event_queue[g_queue_head];
        g_queue_head = (g_queue_head + 1) % EVENT_QUEUE_SIZE;
        g_queue_count--;
        
        __enable_irq();
        
        /* 通知所有订阅该事件的回调 */
        for (uint8_t i = 0; i < g_subscriber_count; i++) {
            if (g_subscribers[i].enabled && 
                g_subscribers[i].event_type == event.type) {
                g_subscribers[i].callback(&event, g_subscribers[i].user_data);
                g_total_dispatched++;
            }
        }
    }
}

/* 快捷发布函数 */
int event_publish_frame_ready(uint8_t *data, uint16_t length)
{
    event_t event = {
        .type = EVENT_USART2_FRAME_READY,
        .priority = 0,  /* 高优先级 */
        .data.frame_data = {.data = data, .length = length}
    };
    return event_bus_publish(&event);
}

int event_publish_motor_error(uint8_t motor_id, uint8_t error_code)
{
    event_t event = {
        .type = EVENT_MOTOR_ERROR,
        .priority = 1,
        .data.motor_data = {.motor_id = motor_id, .error_code = error_code}
    };
    return event_bus_publish(&event);
}
```

### 实际应用示例

#### 1. 协议路由订阅Modbus事件

```c
/* Drivers/Middlewares/MODBUS/modbus_gateway.c */

static void on_modbus_frame_received(const event_t *event, void *user_data)
{
    uint8_t *frame_data = event->data.frame_data.data;
    uint16_t frame_len = event->data.frame_data.length;
    
    /* 处理Modbus帧 */
    uint8_t tx_buf[256];
    uint16_t tx_len;
    
    if (modbus_rtu_process_request(frame_data, frame_len, tx_buf, &tx_len) == 0) {
        /* 发送响应 */
        emm_uart_send(tx_buf, tx_len);
    }
}

void modbus_gateway_init(void)
{
    /* 订阅Modbus事件 */
    event_bus_subscribe(EVENT_MODBUS_FRAME_RECEIVED, 
                        on_modbus_frame_received, 
                        NULL);
}
```

#### 2. LED指示订阅错误事件

```c
/* Core/App/led_indicator.c */

static void on_motor_error(const event_t *event, void *user_data)
{
    uint8_t motor_id = event->data.motor_data.motor_id;
    uint8_t error_code = event->data.motor_data.error_code;
    
    /* LED快速闪烁提示错误 */
    for (int i = 0; i < 5; i++) {
        led0_toggle();
        delay_ms(100);
    }
    
    printf("[LED] Motor#%d Error: 0x%02X\r\n", motor_id, error_code);
}

static void on_fifo_overflow(const event_t *event, void *user_data)
{
    /* LED红灯常亮提示FIFO溢出 */
    led0(0);  /* 点亮LED0 */
}

void led_indicator_init(void)
{
    event_bus_subscribe(EVENT_MOTOR_ERROR, on_motor_error, NULL);
    event_bus_subscribe(EVENT_FIFO_OVERFLOW, on_fifo_overflow, NULL);
}
```

#### 3. 主循环简化

```c
/* Core/App/main.c */

int main(void)
{
    /* 初始化 */
    HAL_Init();
    /* ... 其他初始化 ... */
    event_bus_init();
    
    /* 各模块订阅感兴趣的事件 */
    modbus_gateway_init();
    led_indicator_init();
    motor_fsm_init_all();
    
    while (1) {
        /* 主循环只需分发事件 */
        event_bus_dispatch();
        
        /* 看门狗喂狗 */
        iwdg_feed();
        
        delay_ms(10);
    }
}
```

#### 4. 中断中发布事件

```c
/* Drivers/SYSTEM/usart/usart.c */

static void usart2_idle_callback(UART_HandleTypeDef *huart)
{
    idle_count++;
    __HAL_UART_CLEAR_IDLEFLAG(huart);
    
    /* 发布IDLE事件（而非直接设置全局标志）*/
    event_t event = {
        .type = EVENT_USART2_IDLE,
        .priority = 0
    };
    event_bus_publish(&event);  /* 中断安全 */
}

/* FIFO溢出检测 */
if (emm_fifo_enqueue((uint16_t)data) != 0) {
    g_fifo_overflow_count++;
    
    /* 发布溢出事件 */
    event_t event = {.type = EVENT_FIFO_OVERFLOW, .priority = 1};
    event_bus_publish(&event);
}
```

## 架构优势

### 1. 解耦模块
```
传统方式（紧耦合）:
main.c → 直接调用 → modbus_gateway.c
                  → led_indicator.c
                  → motor_fsm.c

观察者模式（松耦合）:
main.c → 发布事件 → Event Bus → 通知订阅者 → modbus_gateway.c
                                           → led_indicator.c
                                           → motor_fsm.c
```

### 2. 易于扩展

添加新功能无需修改现有代码：

```c
/* 新增日志模块（无需修改main.c）*/
void logger_init(void)
{
    /* 订阅所有事件记录日志 */
    for (event_type_t type = 0; type < EVENT_TYPE_MAX; type++) {
        event_bus_subscribe(type, log_event, NULL);
    }
}

static void log_event(const event_t *event, void *user_data)
{
    /* 写入Flash或SD卡 */
    flash_log_write(event->type, event->timestamp);
}
```

### 3. 优先级调度

修改`event_bus_dispatch()`支持优先级队列：

```c
void event_bus_dispatch(void)
{
    /* 按优先级排序后分发 */
    while (g_queue_count > 0) {
        /* 找出最高优先级事件 */
        uint8_t highest_priority_idx = find_highest_priority_event();
        
        /* 分发该事件 */
        dispatch_event_at_index(highest_priority_idx);
    }
}
```

## 资源占用

```
Flash: +1KB (事件总线实现)
RAM:   ~600 bytes (16订阅者×32字节 + 8事件队列×40字节)
```

## 性能优化建议

1. **零拷贝优化**：事件数据使用指针传递，避免大块内存复制
2. **事件池化**：结合内存池模式，预分配事件对象
3. **延迟分发**：低优先级事件延迟到系统空闲时处理

## USMART调试命令

```c
void event_stats(void)
{
    printf("Event Bus Statistics:\r\n");
    printf("Published:  %lu\r\n", g_total_published);
    printf("Dispatched: %lu\r\n", g_total_dispatched);
    printf("Overflow:   %lu\r\n", g_queue_overflow);
    printf("Queue:      %u/%u\r\n", g_queue_count, EVENT_QUEUE_SIZE);
    printf("Subscribers: %u/%u\r\n", g_subscriber_count, EVENT_BUS_MAX_SUBSCRIBERS);
}
```
