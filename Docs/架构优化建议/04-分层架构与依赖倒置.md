# 分层架构与依赖倒置原则（DIP）

## 当前架构问题

分析现有代码依赖关系：

```
当前依赖链（紧耦合）:
motor_zdt.c → emm_v5.c → emm_uart.c → usart.c → HAL库
           ↘
            modbus_gateway.c → modbus_rtu.c → usart.c

问题:
1. 高层模块（motor_zdt）直接依赖底层细节（emm_uart）
2. 无法轻松切换通信方式（RS485 → CAN/Ethernet）
3. 单元测试困难（无法mock硬件层）
```

## 设计方案：分层架构 + 抽象接口

### 四层架构模型

```
┌─────────────────────────────────────────────────┐
│  应用层 (Application Layer)                      │
│  motor_zdt.c, main.c                             │
│  职责: 业务逻辑、用户交互、流程控制              │
└────────────────┬────────────────────────────────┘
                 ↓ 依赖抽象接口
┌─────────────────────────────────────────────────┐
│  服务层 (Service Layer)                          │
│  motor_service.h (抽象接口)                      │
│  职责: 定义电机控制、通信的抽象接口              │
└────────────────┬────────────────────────────────┘
                 ↓ 多种实现
┌─────────────────────────────────────────────────┐
│  协议层 (Protocol Layer)                         │
│  emm_v5_impl.c, modbus_impl.c                    │
│  职责: 实现具体协议逻辑                          │
└────────────────┬────────────────────────────────┘
                 ↓ 依赖抽象接口
┌─────────────────────────────────────────────────┐
│  硬件抽象层 (HAL)                                │
│  comm_hal.h (抽象接口)                           │
│  职责: 定义通信硬件抽象（UART/SPI/CAN/Ethernet）│
└────────────────┬────────────────────────────────┘
                 ↓ 多种实现
┌─────────────────────────────────────────────────┐
│  驱动层 (Driver Layer)                           │
│  uart_driver.c, can_driver.c                     │
│  职责: 操作具体硬件寄存器                        │
└─────────────────────────────────────────────────┘
```

### 核心抽象接口设计

#### 1. 电机服务接口（Service Layer）

```c
/* Drivers/Services/motor_service.h */
#ifndef __MOTOR_SERVICE_H
#define __MOTOR_SERVICE_H

#include <stdint.h>
#include <stdbool.h>

/* 电机服务接口（抽象类）*/
typedef struct motor_service_ops {
    /* 基础控制 */
    int (*enable)(uint8_t addr, bool enable);
    int (*stop)(uint8_t addr);
    
    /* 运动控制 */
    int (*move_absolute)(uint8_t addr, int32_t position, uint16_t speed);
    int (*move_relative)(uint8_t addr, int32_t distance, uint16_t speed);
    int (*move_velocity)(uint8_t addr, int16_t velocity);
    
    /* 状态查询 */
    int (*get_position)(uint8_t addr, int32_t *position);
    int (*get_status)(uint8_t addr, uint8_t *status);
    
    /* 高级功能 */
    int (*home)(uint8_t addr, uint8_t mode);
    int (*set_zero)(uint8_t addr);
    
} motor_service_ops_t;

/* 电机服务上下文 */
typedef struct {
    const motor_service_ops_t *ops;  /* 操作接口（多态）*/
    void *private_data;              /* 实现特定数据 */
} motor_service_t;

/* 全局服务实例（由main.c初始化）*/
extern motor_service_t *g_motor_service;

/* 便捷宏（应用层使用）*/
#define MOTOR_ENABLE(addr, en)  g_motor_service->ops->enable(addr, en)
#define MOTOR_MOVE_ABS(addr, pos, spd)  g_motor_service->ops->move_absolute(addr, pos, spd)
#define MOTOR_HOME(addr, mode)  g_motor_service->ops->home(addr, mode)

#endif
```

#### 2. EMM_V5协议实现（Protocol Layer）

```c
/* Drivers/Services/Implementations/emm_v5_service.c */
#include "motor_service.h"
#include "emm_v5.h"

/* EMM_V5私有数据 */
typedef struct {
    uint16_t default_speed;
    uint8_t default_accel;
} emm_v5_private_t;

/* EMM_V5实现函数 */
static int emm_v5_enable_impl(uint8_t addr, bool enable)
{
    Emm_V5_En_Control(addr, enable, false);
    return 0;
}

static int emm_v5_move_absolute_impl(uint8_t addr, int32_t position, uint16_t speed)
{
    emm_v5_private_t *priv = (emm_v5_private_t*)g_motor_service->private_data;
    
    /* 转换为EMM_V5协议的相对脉冲 */
    int32_t current_pos = 0;  /* 需实现位置跟踪 */
    int32_t pulses = position - current_pos;
    uint8_t dir = (pulses >= 0) ? 0 : 1;
    
    Emm_V5_Pos_Control(addr, dir, speed, priv->default_accel, 
                       abs(pulses), false, false);
    return 0;
}

static int emm_v5_home_impl(uint8_t addr, uint8_t mode)
{
    Emm_V5_Origin_Trigger_Return(addr, mode, false);
    return 0;
}

/* EMM_V5操作表 */
static const motor_service_ops_t emm_v5_ops = {
    .enable = emm_v5_enable_impl,
    .stop = [](uint8_t addr) { Emm_V5_Stop_Now(addr, false); return 0; },
    .move_absolute = emm_v5_move_absolute_impl,
    .move_relative = [](uint8_t addr, int32_t dist, uint16_t spd) {
        uint8_t dir = (dist >= 0) ? 0 : 1;
        Emm_V5_Pos_Control(addr, dir, spd, 10, abs(dist), false, false);
        return 0;
    },
    .home = emm_v5_home_impl,
    /* ... 其他实现 ... */
};

/* 创建EMM_V5服务实例 */
motor_service_t* emm_v5_service_create(void)
{
    static motor_service_t service;
    static emm_v5_private_t priv = {
        .default_speed = 300,
        .default_accel = 10
    };
    
    service.ops = &emm_v5_ops;
    service.private_data = &priv;
    
    return &service;
}
```

#### 3. 通信硬件抽象（HAL）

```c
/* Drivers/HAL/comm_hal.h */
#ifndef __COMM_HAL_H
#define __COMM_HAL_H

#include <stdint.h>

/* 通信接口抽象 */
typedef struct comm_hal_ops {
    int (*init)(uint32_t baudrate);
    int (*send)(const uint8_t *data, uint16_t length);
    int (*receive)(uint8_t *data, uint16_t max_length, uint32_t timeout_ms);
    void (*set_direction)(bool tx_enable);  /* RS485方向控制 */
} comm_hal_ops_t;

/* 通信HAL上下文 */
typedef struct {
    const comm_hal_ops_t *ops;
    void *hw_handle;  /* 硬件句柄（UART_HandleTypeDef等）*/
} comm_hal_t;

extern comm_hal_t *g_comm_hal;

#endif
```

#### 4. UART驱动实现（Driver Layer）

```c
/* Drivers/HAL/Implementations/uart_comm_hal.c */
#include "comm_hal.h"
#include "usart.h"

static int uart_init_impl(uint32_t baudrate)
{
    usart2_init(baudrate);
    return 0;
}

static int uart_send_impl(const uint8_t *data, uint16_t length)
{
    return emm_uart_send(data, length);
}

static int uart_receive_impl(uint8_t *data, uint16_t max_len, uint32_t timeout)
{
    /* 从FIFO读取数据 */
    uint16_t count = 0;
    uint32_t start = HAL_GetTick();
    
    while (count < max_len && HAL_GetTick() - start < timeout) {
        uint16_t byte;
        if (emm_fifo_dequeue(&byte) == 0) {
            data[count++] = (uint8_t)byte;
        }
    }
    
    return count;
}

static const comm_hal_ops_t uart_ops = {
    .init = uart_init_impl,
    .send = uart_send_impl,
    .receive = uart_receive_impl,
    .set_direction = NULL  /* UART自动方向控制 */
};

comm_hal_t* uart_comm_hal_create(void)
{
    static comm_hal_t hal;
    hal.ops = &uart_ops;
    hal.hw_handle = &g_uart2_handle;
    return &hal;
}
```

### 应用层使用方式

```c
/* Core/App/main.c */

motor_service_t *g_motor_service = NULL;
comm_hal_t *g_comm_hal = NULL;

void system_init(void)
{
    HAL_Init();
    /* ... 硬件初始化 ... */
    
    /* 1. 选择通信硬件实现（运行时可切换）*/
    #ifdef USE_UART_COMM
        g_comm_hal = uart_comm_hal_create();
    #elif defined(USE_CAN_COMM)
        g_comm_hal = can_comm_hal_create();
    #endif
    
    g_comm_hal->ops->init(115200);
    
    /* 2. 选择电机协议实现（运行时可切换）*/
    #ifdef USE_EMM_V5_PROTOCOL
        g_motor_service = emm_v5_service_create();
    #elif defined(USE_MODBUS_PROTOCOL)
        g_motor_service = modbus_motor_service_create();
    #endif
}

/* Core/App/motor_zdt.c */
void motor_zdt_test(void)
{
    /* 应用层只依赖抽象接口，无需关心底层实现 */
    MOTOR_ENABLE(0x01, true);
    delay_ms(100);
    
    MOTOR_HOME(0x01, 0);  /* 回零 */
    delay_ms(5000);
    
    MOTOR_MOVE_ABS(0x01, 3200, 300);  /* 移动到绝对位置3200 */
}
```

## 架构优势

### 1. 易于测试（Mock）

```c
/* Tests/mock_motor_service.c */

/* 创建Mock电机服务用于单元测试 */
static int mock_enable(uint8_t addr, bool enable) {
    printf("[MOCK] Enable motor %d: %s\r\n", addr, enable ? "ON" : "OFF");
    return 0;
}

static const motor_service_ops_t mock_ops = {
    .enable = mock_enable,
    /* ... 其他Mock实现 ... */
};

motor_service_t* mock_motor_service_create(void) {
    static motor_service_t mock_service;
    mock_service.ops = &mock_ops;
    return &mock_service;
}

/* 测试代码 */
void test_motor_zdt(void)
{
    /* 注入Mock服务 */
    g_motor_service = mock_motor_service_create();
    
    /* 测试应用层逻辑（无需真实硬件）*/
    motor_zdt_test();
}
```

### 2. 轻松切换实现

```c
/* 从RS485切换到CAN总线（无需修改应用层代码）*/

// main.c
#ifdef USE_CAN_COMM
    g_comm_hal = can_comm_hal_create();  // 切换硬件实现
#endif

// 应用层代码保持不变
MOTOR_ENABLE(0x01, true);  // 自动通过CAN发送
```

### 3. 遵循SOLID原则

- **单一职责（SRP）**: 每层职责明确
- **开闭原则（OCP）**: 对扩展开放，对修改封闭
- **里氏替换（LSP）**: 任何实现可替换抽象
- **接口隔离（ISP）**: 接口最小化
- **依赖倒置（DIP）**: 高层依赖抽象，不依赖细节

## 实施路线图

### Phase 1: 定义抽象接口（1周）
- [ ] 设计`motor_service.h`接口
- [ ] 设计`comm_hal.h`接口
- [ ] 创建目录结构`Drivers/Services/`

### Phase 2: 重构现有实现（2周）
- [ ] 将`emm_v5.c`改造为`emm_v5_service.c`
- [ ] 实现`uart_comm_hal.c`
- [ ] 更新`motor_zdt.c`使用新接口

### Phase 3: 新增实现（按需）
- [ ] 实现`modbus_motor_service.c`
- [ ] 实现`can_comm_hal.c`
- [ ] 实现`ethernet_comm_hal.c`

## 资源占用评估

```
Flash: +2KB (虚函数表 + 适配器代码)
RAM:   +200 bytes (服务上下文 + 私有数据)
性能损失: ~5% (虚函数调用开销，可通过内联优化)
```

## 注意事项

1. **避免过度设计**: 仅对变化点抽象（如通信方式、协议类型）
2. **性能关键路径**: 中断处理仍直接操作硬件，不经过抽象层
3. **向后兼容**: 保留原有API作为适配器，逐步迁移
