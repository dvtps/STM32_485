# STM32_485 架构重构方案 V3.7 - 反馈闭环系统

**日期**: 2025-12-03  
**版本**: V3.7 (基于V3.6实时系统，增加反馈闭环)  
**作者**: STM32_485 Project Team

---

## 问题诊断

### 当前架构的致命缺陷

```
❌ V3.6 架构问题（乐观更新）
┌──────────────┐
│ 发送命令     │ → 立即更新本地位置（假设成功）
│ printer_move │    g_printer.axes[x].position += distance
└──────────────┘
        ↓
   忽略电机响应帧（浪费闭环电机的编码器反馈）
        ↓
   Y/Z轴无电机 → 位置更新错误但无法检测
```

**根本问题**：
1. **没有利用闭环电机的编码器反馈**（张大头Y系列自带编码器）
2. **无电机检测机制**（Y/Z轴未连接但显示"已使能"）
3. **位置更新不可靠**（基于假设而非实测）
4. **无法检测失步/堵转**（闭环电机的核心优势被浪费）

---

## V3.7 架构：反馈闭环系统

### 核心设计理念

```
✅ V3.7 反馈闭环架构
┌──────────────┐
│ 发送命令     │
│ printer_move │
└──────────────┘
        ↓
   等待响应超时（500ms）
        ↓
   解析响应帧（S_FLAG, S_CPOS, S_PERR）
        ↓
   更新真实状态（基于编码器反馈）
        ↓
   ┌─────────┬─────────┬─────────┐
   │ 成功    │ 超时    │ 失步    │
   │ 更新位置│ 标记离线│ 重试/告警│
   └─────────┴─────────┴─────────┘
```

### 三层反馈机制

#### 1️⃣ 命令级反馈（立即确认）

```c
/* 发送命令后等待电机应答帧 */
bool printer_move_x(int32_t distance, uint16_t speed) {
    // 1. 发送命令
    emm_uart_send(cmd, len);
    
    // 2. 等待响应（100ms超时）
    if (!wait_ack(motor_addr, 100)) {
        return ERROR_NO_RESPONSE;  // 电机离线
    }
    
    // 3. 解析应答（电机是否接受命令）
    return parse_ack();
}
```

#### 2️⃣ 位置级反馈（周期查询）

```c
/* 主循环定期查询电机真实位置 */
void task_motor_position_sync(void) {
    static uint32_t last_query = 0;
    
    if (HAL_GetTick() - last_query > 100) {  // 100ms查询一次
        last_query = HAL_GetTick();
        
        for (uint8_t i = 0; i < MOTOR_COUNT; i++) {
            // 查询当前位置
            Emm_V5_Read_Sys_Params(motor_addr[i], S_CPOS);
            
            // 等待响应并更新
            if (wait_response(50)) {
                int32_t real_pos = parse_position_response();
                g_printer.axes[i].position = real_pos;  // 真实位置
                g_printer.axes[i].online = true;
            } else {
                g_printer.axes[i].online = false;  // 离线
            }
        }
    }
}
```

#### 3️⃣ 状态级反馈（异常检测）

```c
/* 查询电机状态标志位（S_FLAG）*/
typedef struct {
    uint8_t motor_enabled : 1;   // 使能状态
    uint8_t is_homing : 1;       // 回零中
    uint8_t home_done : 1;       // 回零完成
    uint8_t is_clogged : 1;      // 堵转
    uint8_t pos_error_over : 1;  // 位置误差过大
    uint8_t reserved : 3;
} motor_flag_t;

void task_motor_status_check(void) {
    // 查询状态标志
    Emm_V5_Read_Sys_Params(0x01, S_FLAG);
    
    // 解析并处理异常
    motor_flag_t flag = parse_flag_response();
    
    if (flag.is_clogged) {
        printf("[ERROR] Motor clogged!\r\n");
        printer_estop();
    }
    
    if (flag.pos_error_over) {
        printf("[WARN] Position error too large!\r\n");
        // 重新回零或报警
    }
}
```

---

## 实施计划

### Phase 1: 响应帧解析器（1天）

**文件**: `Drivers/BSP/EMM_V5/emm_v5_parser.c/h`

```c
/* 响应帧类型 */
typedef enum {
    RESP_ACK,        // 应答帧（命令接收确认）
    RESP_POSITION,   // 位置查询响应
    RESP_VELOCITY,   // 速度查询响应
    RESP_FLAG,       // 状态标志响应
    RESP_ERROR,      // 错误帧
    RESP_UNKNOWN     // 未知帧
} emm_response_type_t;

/* 解析响应帧 */
emm_response_type_t emm_v5_parse_response(
    const uint8_t *data, 
    uint16_t len, 
    motor_response_t *result
);

/* 等待特定类型的响应 */
bool emm_v5_wait_response(
    uint8_t addr,            // 电机地址
    emm_response_type_t type, // 期待的响应类型
    motor_response_t *result, // 输出结果
    uint32_t timeout_ms       // 超时时间
);
```

### Phase 2: 电机在线检测（半天）

**文件**: `Core/App/motor_online.c/h`

```c
/* 电机在线状态管理 */
typedef struct {
    uint8_t addr;           // 电机地址
    bool online;            // 是否在线
    uint32_t last_seen;     // 最后响应时间
    uint32_t timeout_count; // 超时计数
} motor_online_t;

/* 检测所有电机在线状态 */
void motor_online_detect_all(void);

/* 获取电机在线状态 */
bool motor_is_online(uint8_t addr);
```

### Phase 3: 位置同步系统（1天）

**文件**: `Core/App/printer_axis.c` 重构

```c
/* 修改后的移动函数 */
bool printer_axis_move_relative(
    printer_axis_t axis, 
    int32_t distance, 
    uint16_t speed, 
    uint8_t acc
) {
    // 1. 检查电机在线
    if (!is_motor_online(axis)) {
        printf("[ERROR] Motor offline: axis %d\r\n", axis);
        return false;
    }
    
    // 2. 发送命令
    send_pos_command(...);
    
    // 3. 等待应答（100ms）
    if (!wait_ack(motor_addr, 100)) {
        mark_motor_offline(axis);
        return false;
    }
    
    // 4. 【不立即更新位置】
    //    位置由定期查询任务更新（task_motor_position_sync）
    
    return true;
}
```

### Phase 4: 主循环任务调度重构（半天）

**文件**: `Core/App/app_tasks.c`

```c
void app_tasks_run(void) {
    task_comm_process();         // 通信帧处理（已有）
    task_motor_control();        // 按键控制（已有）
    
    // ✨ 新增任务
    task_motor_online_check();   // 在线检测（每1秒）
    task_motor_position_sync();  // 位置同步（每100ms）
    task_motor_status_check();   // 状态检查（每500ms）
    
    task_watchdog_feed();        // 喂狗（已有）
}
```

---

## 关键数据结构重构

### 轴状态结构（新增字段）

```c
typedef struct {
    /* 原有字段 */
    bool enabled;
    bool homed;
    int32_t position;        // 本地位置缓存
    
    /* ✨ 新增字段 */
    bool online;             // 电机在线状态
    int32_t real_position;   // 编码器反馈的真实位置
    int32_t position_error;  // 位置误差（target - real）
    uint32_t last_response;  // 最后响应时间戳
    uint16_t timeout_count;  // 超时计数
    motor_flag_t status;     // 电机状态标志
    
    /* 统计信息 */
    uint32_t cmd_success;    // 命令成功次数
    uint32_t cmd_timeout;    // 超时次数
    uint32_t cmd_error;      // 错误次数
} axis_state_t;
```

---

## 电机响应帧格式（参考文档）

### 位置查询响应（S_CPOS, 功能码0x36）

```
发送: [01] [36] [6B]
响应: [01] [36] [pos_HH] [pos_HL] [pos_LH] [pos_LL] [6B]

解析:
int32_t position = (rxCmd[2] << 24) | (rxCmd[3] << 16) | 
                   (rxCmd[4] << 8)  | rxCmd[5];
```

### 状态标志响应（S_FLAG, 功能码0x3A）

```
发送: [01] [3A] [6B]
响应: [01] [3A] [flag_byte] [6B]

flag_byte位定义:
Bit 0: 使能状态（1=使能）
Bit 1: 回零中（1=正在回零）
Bit 2: 回零完成（1=已完成）
Bit 3: 堵转（1=检测到堵转）
Bit 4: 位置误差过大（1=误差>阈值）
```

---

## 优势对比

| 特性 | V3.6（乐观更新） | V3.7（反馈闭环） |
|------|-----------------|-----------------|
| 位置准确性 | ❌ 假设成功 | ✅ 编码器真实值 |
| 电机在线检测 | ❌ 无 | ✅ 超时检测 |
| 失步检测 | ❌ 无 | ✅ 位置误差监控 |
| 堵转保护 | ❌ 无 | ✅ S_FLAG监控 |
| 调试能力 | ❌ 位置不准 | ✅ 可对比命令/真实位置 |
| Y/Z无电机场景 | ❌ 显示错误状态 | ✅ 标记离线 |

---

## 内存开销评估

```
新增代码（估算）:
- emm_v5_parser.c:  2KB Flash
- motor_online.c:   1KB Flash
- printer_axis重构: 1KB Flash (优化后)
- 轴状态扩展:       80 bytes RAM (4轴 × 20 bytes)
- 响应缓冲:         256 bytes RAM

总计: +4KB Flash, +336 bytes RAM
当前可用: 22KB Flash, 14KB RAM → 充足
```

---

## 实施优先级

### 🔥 P0（必须）- 周末完成
- [ ] Phase 1: 响应帧解析器
- [ ] Phase 2: 电机在线检测
- [ ] Phase 3: 位置同步（S_CPOS查询）

### ⚡ P1（重要）- 下周完成
- [ ] Phase 4: 状态监控（S_FLAG查询）
- [ ] 位置误差告警（S_PERR）
- [ ] 回零状态监控（S_ORG）

### 💡 P2（优化）- 后续迭代
- [ ] 自动重试机制
- [ ] 堵转自动恢复
- [ ] 位置校准算法

---

## 测试用例

### TC1: 电机在线检测

```c
// 测试步骤
1. 只连接X轴电机（地址0x01）
2. 启动系统
3. 执行 printer_show_status()

// 预期结果
X-Axis: Online=YES, Position=0
Y-Axis: Online=NO, Position=N/A
Z-Axis: Online=NO, Position=N/A
```

### TC2: 位置反馈验证

```c
// 测试步骤
1. printer_move_x(3200, 800)  // 命令移动1圈
2. 延时2秒等待运动完成
3. printer_show_status()

// 预期结果
X-Axis: Cmd_Pos=3200, Real_Pos=3200, Error=0
```

### TC3: 无响应容错

```c
// 测试步骤
1. 运行中断开X轴电机电源
2. printer_move_x(1600, 800)

// 预期结果
[ERROR] Motor offline: axis 0
Command failed
X-Axis: Online=NO
```

---

## 迁移路径

### 向后兼容性

```c
/* V3.6旧代码可继续使用（兼容层）*/
#define OLD_API_COMPATIBLE 1

#if OLD_API_COMPATIBLE
// 旧API内部调用新实现
bool printer_axis_move_relative_v36(axis, dist, speed, acc) {
    return printer_axis_move_relative(axis, dist, speed, acc);
}
#endif
```

---

## 结论

**V3.7架构充分利用了闭环电机的编码器反馈**，实现：
1. ✅ 真实位置监控（不再"自以为是"）
2. ✅ 电机在线检测（Y/Z无电机立即发现）
3. ✅ 失步/堵转保护（生产级可靠性）
4. ✅ 调试能力增强（对比命令/实际位置）

**代价可控**：+4KB Flash, +336B RAM，STM32F103C8完全够用。

---

**批准**: [待审核]  
**开始日期**: 2025-12-03  
**预计完成**: 2025-12-05
